/*
Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

package v1;

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "buf/validate/validate.proto";

import "v1/mesh.proto";
import "v1/node.proto";
import "v1/storage_query.proto";

// ConnectRequest is sent by an application to a daemon to establish a connection to a mesh.
message ConnectRequest {
    // AddrType is the type of join addresses included in the request.
    enum AddrType {
        // ADDR is used to join a mesh using an IP or DNS address.
        ADDR = 0;
        // MULTIADDR is used to join a mesh using a multiaddr.
        MULTIADDR = 1;
        // RENDEZVOUS is used to join a mesh using a rendezvous string.
        RENDEZVOUS = 2;
    };
    // AuthMethod are types of RPC credentials to supply to the connection.
    enum AuthMethod {
        // NO_AUTH is used to indicate that no authentication is required.
        NO_AUTH = 0;
        // BASIC is used to indicate that basic authentication is required.
        BASIC = 1;
        // LDAP is used to indicate that LDAP authentication is required.
        LDAP = 2;
        // ID is used to indicate that an identity is required.
        ID = 3;
        // MTLS is used to indicate that mutual TLS authentication is required.
        // The TLS object should be used to configure the TLS connection.
        MTLS = 4;
    };
    // AuthHeader is an enumeration of headers that coorespond to the AuthMethod.
    // They are used to pass authentication credentials to the daemon. Enums 
    // cannot be used as map keys, so their string values are used instead.
    enum AuthHeader {
        // BASIC_USERNAME is the username for basic authentication.
        BASIC_USERNAME = 0;
        // BASIC_PASSWORD is the password for basic authentication.
        BASIC_PASSWORD = 1;
        // LDAP_USERNAME is the username for LDAP authentication.
        LDAP_USERNAME = 2;
        // LDAP_PASSWORD is the password for LDAP authentication.
        LDAP_PASSWORD = 3;
        // ADDRS_ENVELOPE is the header for a signed envelope containing
        // the join addresses to use to connect to the mesh.
        ADDRS_ENVELOPE = 4;
    };
    // ID is the unique identifier of this connection. If not provided
    // one will be generated.
    string id = 1 [(buf.validate.field).string.max_len = 64];
    // AuthMethod is the type of authentication to use.
    AuthMethod authMethod = 2 [(buf.validate.field).enum.defined_only = true];
    // AuthCredentials are additional credentials as required by the authType. 
    map<string, bytes> authCredentials = 3;
    // AddrType is the type of join addresses in the addrs list.
    AddrType addrType = 4 [(buf.validate.field).enum.defined_only = true];
    // Addrs are the join addresses to use to connect to the mesh.
    repeated string addrs = 5;
    // Networking is the networking configuration to use.
    MeshConnNetworking networking = 6;
    // Services are the services to expose to other nodes on the mesh.
    MeshConnServices services = 7;
    // Bootstrap are options for bootstrapping a new mesh.
    MeshConnBootstrap bootstrap = 8;
    // TLS are TLS configurations for the mesh connection.
    MeshConnTLS tls = 9;

    option (buf.validate.message).cel = {
        id: "connectRequest.requiredAddresses",
        message: "Must provide at least one address string when not bootstrapping",
        expression: "!this.bootstrap.enabled && size(this.addrs) > 0",
    };

    option (buf.validate.message).cel = {
        id: "connectRequest.mtlsConnectionSecurity",
        message: "Cannot disable TLS when using mTLS",
        expression: "this.authMethod != 4 || this.tls.enabled",
    };

    option (buf.validate.message).cel = {
        id: "connectRequest.tlsRequiredFields",
        message: "Must provide a TLS certificate and key for mTLS authentication",
        expression: "this.authMethod != 4 || (size(this.tls.certData) > 0 && size(this.tls.keyData) > 0)",
    };
}

// MeshConnNetworking are configurations for networking on a mesh.
message MeshConnNetworking {
    // UseDNS indicates whether or not to use the DNS servers of the mesh.
    bool useDNS = 1;
}

// MeshConnServices are configurations for exposing services to other nodes on a mesh.
message MeshConnServices {
    // Enabled indicates whether or not to expose services to other nodes.
    bool enabled = 1;
    // Public indicates that the services should be exposed publicly.
    // This is useful for allowing other nodes to connect to the mesh
    // via this node's public IP address.
    bool public = 2;
}

// MeshConnBootstrap are configurations for bootstrapping a new mesh.
message MeshConnBootstrap {
    // Enabled indicates whether or not to bootstrap a new mesh.
    bool enabled = 1;
    // Domain is the domain of the mesh. Defaults to "webmesh.internal".
    string domain = 2 [(buf.validate.field).string.hostname = true];
    // IPv4Network is the IPv4 network of the mesh. Defaults to 172.16.0.0/12.
    string ipv4Network = 3 [(buf.validate.field).string.ipv4 = true];
    // RBACEnabled indicates whether or not to enable RBAC on the mesh.
    bool rbacEnabled = 4;

    enum DefaultNetworkACL {
        ACCEPT = 0;
        DROP = 1;
    }

    // DefaultNetworkACL is the default network ACL to use for the mesh.
    DefaultNetworkACL defaultNetworkACL = 5 [(buf.validate.field).enum.defined_only = true];
}

// MeshhConnTLS are TLS configurations for a mesh connection.
message MeshConnTLS {
    // Enabled indicates whether or not to use TLS.
    bool enabled = 1;
    // CACert is a PEM-encoded CA certificate to use for TLS.
    bytes caCertData = 2;
    // CertData is a PEM-encoded certificate to use for TLS.
    bytes certData = 3;
    // KeyData is a PEM-encoded private key to use for TLS.
    bytes keyData = 4;
    // VerifyChainOnly indicates whether or not to only verify the
    // certificate chain.
    bool verifyChainOnly = 5;
    // SkipVerify indicates whether or not to skip verification of the
    // server certificate.
    bool skipVerify = 6;
};

// ConnectResponse is returned by the Connect RPC.
message ConnectResponse {
    // ID is the unique identifier of this connection.
    string id = 1;
    // Node id is the unique identifier of the node.
    string nodeID = 2;
    // Mesh domain is the domain of the mesh.
    string meshDomain = 3;
    // IPv4Address is the IPv4 address of the node.
    string ipv4Address = 4;
    // IPv6Address is the IPv6 address of the node.
    string ipv6Address = 5;
    // IPv4Network is the IPv4 network of the mesh.
    string ipv4Network = 6;
    // IPv6Network is the IPv6 network of the mesh.
    string ipv6Network = 7;
}

// DisconnectRequest is sent by an application to a daemon to disconnect
// from a mesh. This message will eventually contain unique identifiers
// for allowing the application to disconnect from a specific mesh.
message DisconnectRequest {
    // ID is the unique identifier of this connection.
    string id = 1 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 64
    ];
}

// DisconnectResponse is returned by the Disconnect RPC.
message DisconnectResponse {}

// MetricsRequest is sent by the application to a daemon to retrieve interface
// metrics for a mesh connection.
message MetricsRequest {
    // IDs are the unique identifiers of the connections to retrieve metrics for.
    // If not provided, metrics for all connections will be returned.
    repeated string ids = 1;
}

// MetricsResponse is a message containing interface metrics.
message MetricsResponse {
    // Interfaces is a map of network IDs to their interface metrics.
    map<string, InterfaceMetrics> interfaces = 1;
}

// StatusRequest is sent by the application to a daemon to retrieve the status
// of a mesh connection.
message StatusRequest {
    // ID is the unique identifier of this connection.
    string id = 1 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 64
    ];
}

// StatusResponse is a message containing the status of the node.
message StatusResponse {
    enum ConnectionStatus {
        // DISCONNECTED indicates that the node is not connected to a mesh.
        DISCONNECTED = 0;
        // CONNECTING indicates that the node is in the process of connecting to a mesh.
        CONNECTING = 1;
        // CONNECTED indicates that the node is connected to a mesh.
        CONNECTED = 2;
    }
    // ConnectionStatus is the status of the connection.
    ConnectionStatus connectionStatus = 1;
    // Node is the node status. This is only populated if the node is connected.
    MeshNode node = 2;
}

// AppQueryRequest is sent by the application to a daemon to query a mesh's storage.
message AppQueryRequest {
    // ID is the unique identifier of this connection.
    string id = 1 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 64
    ];
    // Query is the query to execute.
    QueryRequest query = 2;
}

// AppSubscribeRequest is sent by the application to a daemon to subscribe to a mesh's storage.
message AppSubscribeRequest {
    // ID is the unique identifier of this connection.
    string id = 1 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 64
    ];
    // Subscribe is the subscription to execute.
    SubscribeRequest subscribe = 2;
}

// AppPublishRequest is sent by the application to a daemon to publish to a mesh's storage.
message AppPublishRequest {
    // ID is the unique identifier of this connection.
    string id = 1 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 64
    ];
    // Publish is the publish to execute.
    PublishRequest publish = 2;
}

// AppDaemon is exposed by nodes running in the app-daemon mode. This mode
// allows the node to run in an idle state and be controlled by an application.
// The application can send commands to the node to execute tasks and receive 
// responses.
service AppDaemon {
    // Connect is used to establish a connection between the node and a mesh.
    rpc Connect(ConnectRequest) returns (ConnectResponse) {}

    // Disconnect is used to disconnect the node from a mesh.
    rpc Disconnect(DisconnectRequest) returns (DisconnectResponse) {}

    // Metrics is used to retrieve interface metrics for a mesh connection.
    rpc Metrics(MetricsRequest) returns (MetricsResponse) {}

    // Status is used to retrieve the status a mesh connection.
    rpc Status(StatusRequest) returns (StatusResponse) {}

    // Query is used to query a mesh for information.
    rpc Query(AppQueryRequest) returns (QueryResponse) {}

    // Subscribe is used to subscribe to events in a mesh database.
    rpc Subscribe(AppSubscribeRequest) returns (stream SubscriptionEvent) {}

    // Publish is used to publish events to a mesh database.
    rpc Publish(AppPublishRequest) returns (PublishResponse) {}
}
