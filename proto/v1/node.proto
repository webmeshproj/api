/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

package v1;

import "google/protobuf/timestamp.proto";

// ClusterStatus is the status of the node in the cluster.
enum ClusterStatus {
    // CLUSTER_STATUS_UNKNOWN is the default status.
    CLUSTER_STATUS_UNKNOWN = 0;
    // CLUSTER_LEADER is the status for the leader node.
    CLUSTER_LEADER = 1;
    // CLUSTER_VOTER is the status for a voter node.
    CLUSTER_VOTER = 2;
    // CLUSTER_NON_VOTER is the status for a non-voter node.
    CLUSTER_NON_VOTER = 3;
    // CLUSTER_NODE is the status of a node that is not a part
    // of the raft cluster.
    CLUSTER_NODE = 4;
}

// Feature is a list of features supported by a node.
enum Feature {
    // FEATURE_NONE is the default feature set.
    FEATURE_NONE = 0;
    // NODES is the feature for nodes. This is always supported.
    NODES = 1;
    // LEADER_PROXY is the feature for leader proxying.
    LEADER_PROXY = 2;
    // MESH_API is the feature for the mesh API.
    // This will be deprecated in favor of the MEMBERSHIP feature.
    MESH_API = 3;
    // ADMIN_API is the feature for the admin API.
    ADMIN_API = 4;
    // MEMBERSHIP is the feature for membership. This is always supported on raft members.
    MEMBERSHIP = 5;
    // METRICS is the feature for exposing metrics.
    METRICS = 6;
    // ICE_NEGOTIATION is the feature for ICE negotiation.
    ICE_NEGOTIATION = 7;
    // TURN_SERVER is the feature for TURN server.
    TURN_SERVER = 8;
    // MESH_DNS is the feature for mesh DNS.
    MESH_DNS = 9;
    // FORWARD_MESH_DNS is the feature for forwarding mesh DNS lookups to other meshes.
    FORWARD_MESH_DNS = 10;
    // STORAGE is the feature for querying, publishing, and subscribing to mesh state.
    STORAGE = 11;
    // RAFT is the feature for participating in raft consensus.
    RAFT = 12;
}

// FeaturePort describes a feature and the port it is advertised on.
message FeaturePort {
    // feature is the feature.
    Feature feature = 1;
    // port is the port the feature is advertised on.
    int32 port = 2;
}

// MeshNode is a node that has been registered with the mesh.
message MeshNode {
    // id is the ID of the node.
    string id = 1;
    // primary_endpoint is the primary endpoint of the node.
    string primary_endpoint = 2;
    // wireguard_endpoints is a list of WireGuard endpoints for the node.
    repeated string wireguard_endpoints = 3;
    // zone_awareness_id is the zone awareness ID of the node.
    string zone_awareness_id = 4;
    // public_key is the public key of the node.
    string public_key = 5;
    // private_ipv4 is the private IPv4 address of the node.
    string private_ipv4 = 6;
    // private_ipv6 is the private IPv6 address of the node.
    string private_ipv6 = 7;
    // cluster_status is the status of the node in the cluster.
    ClusterStatus cluster_status = 8;
    // features are a list of features and the ports they are advertised on.
    repeated FeaturePort features = 9;
    // joined_at is the time the node joined the cluster.
    google.protobuf.Timestamp joined_at = 10;
}

// NodeList is a list of nodes.
message NodeList {
    // nodes is the list of nodes.
    repeated MeshNode nodes = 1;
}

// DataChannel are the data channels used when communicating over ICE
// with a node.
enum DataChannel {
  // CHANNELS is the data channel used for negotiating new channels.
  // This is the first channel that is opened. The ID of the channel
  // should be 0.
  CHANNELS = 0;
  // CONNECTIONS is the data channel used for negotiating new connections.
  // This is a channel that is opened for each incoming connection from a
  // client. The ID should start at 0 and be incremented for each new connection.
  CONNECTIONS = 1;
}

// GetStatusRequest is a request to get the status of a node.
message GetStatusRequest {
    // id is the ID of the node. If unset, the status of the 
    // local node is returned.
    string id = 1;
}

// Status represents the status of a node.
message Status {
    // id is the ID of the node.
    string id = 1;
    // version is the version of the node.
    string version = 2;
    // commit is the commit of the node.
    string commit = 3;
    // build_date is the build date of the node.
    string build_date = 4;
    // uptime is the uptime of the node.
    string uptime = 5;
    // started_at is the time the node started.
    google.protobuf.Timestamp started_at = 6;
    // features is the list of features currently enabled.
    repeated Feature features = 7;
    // cluster_status is the status of the node in the cluster.
    ClusterStatus cluster_status = 8;
    // current_leader is the current leader of the cluster.
    string current_leader = 9;
    // current_term is the current term of the cluster.
    uint64 current_term = 10;
    // last_log_index is the last log index of the cluster.
    uint64 last_log_index = 11;
    // last_applied is the last applied index of the cluster.
    uint64 last_applied = 12;
    // interface_metrics are the metrics for the node's interfaces.
    InterfaceMetrics interface_metrics = 13;
}

// DataChannelNegotiation is the message for communicating data channels to nodes.
message DataChannelNegotiation {
  // proto is the protocol of the traffic.
  string proto = 1;
  // src is the address of the client that initiated the request.
  string src = 2;
  // dst is the destination address of the traffic.
  string dst = 3;
  // port is the destination port of the traffic.
  uint32 port = 4;
  // offer is the offer for the node to use as its local description.
  string offer = 5;
  // answer is the answer for the node to use as its remote description.
  string answer = 6;
  // candidate is an ICE candidate.
  string candidate = 7;
  // stun_servers is the list of STUN servers to use.
  repeated string stun_servers = 8;
}

// InterfaceMetrics is the metrics for the WireGuard interface on a node.
message InterfaceMetrics {
  // device_name is the name of the device.
  string device_name = 1;
  // public_key is the public key of the node.
  string public_key = 2;
  // address_v4 is the IPv4 address of the node.
  string address_v4 = 3;
  // address_v6 is the IPv6 address of the node.
  string address_v6 = 4;
  // type is the type of interface being used for wireguard.
  string type = 5;
  // listen_port is the port wireguard is listening on.
  int32 listen_port = 6;
  // total_receive_bytes is the total number of bytes received.
  uint64 total_receive_bytes = 7;
  // total_transmit_bytes is the total number of bytes transmitted.
  uint64 total_transmit_bytes = 8;
  // num_peers is the number of peers connected to the node.
  int32 num_peers = 9;
  // peers are the per-peer statistics.
  repeated PeerMetrics peers = 10;
}

// PeerMetrics are the metrics for a node's peer.
message PeerMetrics {
  // public_key is the public key of the peer.
  string public_key = 1;
  // endpoint is the connected endpoint of the peer.
  string endpoint = 2;
  // persistent_keep_alive is the persistent keep alive interval for the peer.
  string persistent_keep_alive = 3;
  // last_handshake_time is the last handshake time for the peer.
  string last_handshake_time = 4;
  // allowed_ips is the list of allowed IPs for the peer.
  repeated string allowed_ips = 5;
  // protocol_version is the version of the wireguard protocol negotiated with the peer.
  int64 protocol_version = 6;
  // receive_bytes is the bytes received from the peer.
  uint64 receive_bytes = 7;
  // transmit_bytes is the bytes transmitted to the peer.
  uint64 transmit_bytes = 8;
}

// WebRTCSignal is a signal sent to a remote peer over the WebRTC API.
message WebRTCSignal {
  // node_id is the ID of the node to send the signal to.
  // This is set by the original sender. On the node that
  // receives the ReceiveSignalChannel request, this will
  // be set to the ID of the node that sent the request.
  string node_id = 1;
  // candidate is an ICE candidate.
  string candidate = 2;
  // description is a session description.
  string description = 3;
}

// Node is the service exposed on every node in the mesh to communicate network
// information amongst themselves and facilitate inbound/outbound connections.
service Node {
    // GetStatus gets the status of a node in the cluster. If the node is not able
    // to return the status of the ID requested, it should return an error.
    rpc GetStatus(GetStatusRequest) returns (Status) {}

    // NegotiateDataChannel is used to negotiate a WebRTC connection between a webmesh client
    // and a node in the cluster. The handling server will send the target node the source address, 
    // the destination for traffic, and STUN/TURN servers to use for the negotiation. The node
    // responds with an offer to be forwarded to the client. When the handler receives an answer
    // from the client, it forwards it to the node. Once the node receives the answer, the stream
    // can optionally be used to exchange ICE candidates.
    rpc NegotiateDataChannel(stream DataChannelNegotiation) returns (stream DataChannelNegotiation) {}

    // ReceiveSignalChannel is used to receive a request to start a WebRTC connection between a remote
    // node and this node. The node should wait for the client to send an offer, and then respond with
    // an answer. Once the node receives the answer, the stream can optionally be used to exchange ICE
    // candidates.
    rpc ReceiveSignalChannel(stream WebRTCSignal) returns (stream WebRTCSignal) {}
}
