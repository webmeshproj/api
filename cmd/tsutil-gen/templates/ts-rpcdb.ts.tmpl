/**
 * Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{{ $templateName := .TemplateName -}}
{{ $typesRoot := .Spec.TypesPath -}}
import { PromiseClient } from "@connectrpc/connect";
import { AppDaemon } from "{{ $typesRoot }}/app_connect.js";
{{ range $file, $types := .Spec.Imports -}}
import { {{ join $types ", " }} } from "{{ $typesRoot }}/{{ $file }}.js";
{{ end -}}
import { 
	QueryRequest_QueryCommand,
	QueryRequest_QueryType,
	QueryResponse
} from "{{ $typesRoot }}/storage_query_pb.js";

{{ range .Spec.Interfaces }}
/**
 * {{ .Name }} is the interface for working with {{ .Name }}s over the AppDaemon query RPC.
 *
 * @generated from {{ $templateName }}
 */
export class {{ .Name }}s {
	/**
	 * @param client - the client to use for RPC calls
	 * @param connID - the connection ID to use for RPC calls
	 */
	constructor(private readonly client: PromiseClient<typeof AppDaemon>, private readonly connID: string) {
	}

	/**
	 * get returns the {{ .Name }} with the given ID.
	 *
	 * @param id - the ID of the {{ .Name }} to get
	 * @returns the {{ .Name }} with the given ID
	 */
	get(id: string): Promise<{{ .Name }}> {
		return new Promise((resolve, reject) => {
			this.client.query({
				id: this.connID,
				query: {
					command: QueryRequest_QueryCommand.GET,
					type: QueryRequest_QueryType.{{ .QueryType }},
					query: 'id=' + id,
				}
			}).then((res: QueryResponse) => {
				if (res.items.length == 0) {
					reject(new Error("{{ .Name }} not found"))
					return
				}
				resolve({{ .Name }}.fromJson(res.items[0].toString()))
			}).catch((err: Error) => {
				reject(err)
			})
		});
	}

	/**
	 * delete deletes the {{ .Name }} with the given ID.
	 *
	 * @param id - the ID of the {{ .Name }} to delete
	 */
	delete(id: string): Promise<void> {
		return new Promise((resolve, reject) => {
			this.client.query({
				id: this.connID,
				query: {
					command: QueryRequest_QueryCommand.DELETE,
					type: QueryRequest_QueryType.{{ .QueryType }},
					query: 'id=' + id,
				}
			}).then(() => {
				resolve()
			}).catch((err: Error) => {
				reject(err)
			})
		});
	}

	/**
	 * list returns all {{ .Name }}s.
	 *
	 * @returns all {{ .Name }}s
	 */
	list(): Promise<{{ .Name }}[]> {
		return new Promise((resolve, reject) => {
			this.client.query({
				id: this.connID,
				query: {
					command: QueryRequest_QueryCommand.LIST,
					type: QueryRequest_QueryType.{{ .QueryType }},
				}
			}).then((res: QueryResponse) => {
				resolve(res.items.map((item) => {{ .Name }}.fromJson(item.toString())))
			}).catch((err: Error) => {
				reject(err)
			})
		});
	}

	/**
	 * put puts the given {{ .Name }}.
	 *
	 * @param obj - the {{ .Name }} to put
	 */
	put(obj: {{ .Name }}): Promise<void> {
		return new Promise((resolve, reject) => {
			const enc = new TextEncoder();
			this.client.query({
				id: this.connID,
				query: {
					command: QueryRequest_QueryCommand.PUT,
					type: QueryRequest_QueryType.{{ .QueryType }},
					item: enc.encode(obj.toJsonString()),
				}
			}).then(() => {
				resolve()
			}).catch((err: Error) => {
				reject(err)
			})
		});
	}
}
{{- end }}
