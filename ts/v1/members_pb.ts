//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file v1/members.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ClusterStatus, FeaturePort, MeshNode } from "./node_pb.js";

/**
 * ConnectProtocol is a type of protocol for establishing a connection into a mesh.
 *
 * @generated from enum v1.ConnectProtocol
 */
export enum ConnectProtocol {
  /**
   * CONNECT_NATIVE indicates that the node should connect to other nodes via the native
   * webmesh mechanisms.
   *
   * @generated from enum value: CONNECT_NATIVE = 0;
   */
  CONNECT_NATIVE = 0,

  /**
   * CONNECT_ICE indicates that the node should connect to other nodes via ICE.
   *
   * @generated from enum value: CONNECT_ICE = 1;
   */
  CONNECT_ICE = 1,

  /**
   * CONNECT_LIBP2P indicates that the node should connect to other nodes via libp2p.
   *
   * @generated from enum value: CONNECT_LIBP2P = 2;
   */
  CONNECT_LIBP2P = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectProtocol)
proto3.util.setEnumType(ConnectProtocol, "v1.ConnectProtocol", [
  { no: 0, name: "CONNECT_NATIVE" },
  { no: 1, name: "CONNECT_ICE" },
  { no: 2, name: "CONNECT_LIBP2P" },
]);

/**
 * JoinRequest is a request to join the cluster.
 *
 * @generated from message v1.JoinRequest
 */
export class JoinRequest extends Message<JoinRequest> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * PublicKey is the public key of the node to broadcast to peers.
   *
   * @generated from field: string publicKey = 2;
   */
  publicKey = "";

  /**
   * PrimaryEndpoint is a routable address for the node. If left unset, 
   * the node is assumed to be behind a NAT and not directly accessible.
   *
   * @generated from field: string primaryEndpoint = 4;
   */
  primaryEndpoint = "";

  /**
   * WireguardEndpoints is a list of WireGuard endpoints for the node.
   *
   * @generated from field: repeated string wireguardEndpoints = 5;
   */
  wireguardEndpoints: string[] = [];

  /**
   * ZoneAwarenessID is the zone awareness ID of the node.
   *
   * @generated from field: string zoneAwarenessID = 6;
   */
  zoneAwarenessID = "";

  /**
   * AssignIPv4 is whether an IPv4 address should be assigned to the node.
   *
   * @generated from field: bool assignIPv4 = 7;
   */
  assignIPv4 = false;

  /**
   * PreferStorageIPv6 is whether IPv6 should be preferred over IPv4 for storage communication.
   * This is only used if assign_ipv4 is true.
   *
   * @generated from field: bool preferStorageIPv6 = 8;
   */
  preferStorageIPv6 = false;

  /**
   * AsVoter is whether the node should receive a vote in elections. The request
   * will be denied if the node is not allowed to vote.
   *
   * @generated from field: bool asVoter = 9;
   */
  asVoter = false;

  /**
   * AsObserver is whether the node should be added as an observer. They will receive
   * updates to the storage, but not be able to vote in elections.
   *
   * @generated from field: bool asObserver = 10;
   */
  asObserver = false;

  /**
   * Routes is a list of routes to advertise to peers. The request will be denied
   * if the node is not allowed to put routes.
   *
   * @generated from field: repeated string routes = 11;
   */
  routes: string[] = [];

  /**
   * DirectPeers is a map of extra peers that should be connected to directly over relays. 
   * The provided edge attribute is the callers preference of how the relay should be created.
   * The request will be denied if the node is not allowed to put data channels or edges.
   * The default joining behavior creates direct links between the caller and the joiner.
   * If the caller has a primary endpoint, the joiner will link the caller to all
   * other nodes with a primary endpoint. If the caller has a zone awareness ID,
   * the joiner will link the caller to all other nodes with the same zone awareness ID
   * that also have a primary endpoint.
   *
   * @generated from field: map<string, v1.ConnectProtocol> directPeers = 12;
   */
  directPeers: { [key: string]: ConnectProtocol } = {};

  /**
   * Features is a list of features supported by the node that should be advertised to peers
   * and the port they are available on.
   *
   * @generated from field: repeated v1.FeaturePort features = 13;
   */
  features: FeaturePort[] = [];

  /**
   * Multiaddrs are libp2p multiaddresses this node is listening on.
   *
   * @generated from field: repeated string multiaddrs = 14;
   */
  multiaddrs: string[] = [];

  constructor(data?: PartialMessage<JoinRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.JoinRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "publicKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "primaryEndpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "wireguardEndpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "zoneAwarenessID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "assignIPv4", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "preferStorageIPv6", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "asVoter", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "asObserver", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "routes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "directPeers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(ConnectProtocol)} },
    { no: 13, name: "features", kind: "message", T: FeaturePort, repeated: true },
    { no: 14, name: "multiaddrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinRequest {
    return new JoinRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinRequest {
    return new JoinRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinRequest {
    return new JoinRequest().fromJsonString(jsonString, options);
  }

  static equals(a: JoinRequest | PlainMessage<JoinRequest> | undefined, b: JoinRequest | PlainMessage<JoinRequest> | undefined): boolean {
    return proto3.util.equals(JoinRequest, a, b);
  }
}

/**
 * JoinResponse is a response to a join request.
 *
 * @generated from message v1.JoinResponse
 */
export class JoinResponse extends Message<JoinResponse> {
  /**
   * AddressIPv4 is the private IPv4 wireguard address of the node
   * in CIDR format representing the network. This is only set if
   * assign_ipv4 was set in the request or no network_ipv6 was provided.
   *
   * @generated from field: string addressIPv4 = 1;
   */
  addressIPv4 = "";

  /**
   * AddressIPv6 is the IPv6 network assigned to the node.
   *
   * @generated from field: string addressIPv6 = 2;
   */
  addressIPv6 = "";

  /**
   * NetworkIPv4 is the IPv4 network of the Mesh.
   *
   * @generated from field: string networkIPv4 = 3;
   */
  networkIPv4 = "";

  /**
   * NetworkIPv6 is the IPv6 network of the Mesh.
   *
   * @generated from field: string networkIPv6 = 4;
   */
  networkIPv6 = "";

  /**
   * Peers is a list of wireguard peers to connect to.
   *
   * @generated from field: repeated v1.WireGuardPeer peers = 5;
   */
  peers: WireGuardPeer[] = [];

  /**
   * ICEServers is a list of public nodes that can be used to negotiate
   * ICE connections if required. This may only be populated when one of
   * the peers has the ICE flag set. This must be set if the requestor
   * specifies direct_peers.
   *
   * @generated from field: repeated string iceServers = 6;
   */
  iceServers: string[] = [];

  /**
   * DNSServers is a list of peers offering DNS services.
   *
   * @generated from field: repeated string dnsServers = 7;
   */
  dnsServers: string[] = [];

  /**
   * MeshDomain is the domain of the mesh.
   *
   * @generated from field: string meshDomain = 8;
   */
  meshDomain = "";

  constructor(data?: PartialMessage<JoinResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.JoinResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "addressIPv4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "addressIPv6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "networkIPv4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "networkIPv6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "peers", kind: "message", T: WireGuardPeer, repeated: true },
    { no: 6, name: "iceServers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "dnsServers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "meshDomain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinResponse {
    return new JoinResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinResponse {
    return new JoinResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinResponse {
    return new JoinResponse().fromJsonString(jsonString, options);
  }

  static equals(a: JoinResponse | PlainMessage<JoinResponse> | undefined, b: JoinResponse | PlainMessage<JoinResponse> | undefined): boolean {
    return proto3.util.equals(JoinResponse, a, b);
  }
}

/**
 * UpdateRequest contains most of the same fields as JoinRequest, but is
 * used to update the state of a node in the cluster.
 *
 * @generated from message v1.UpdateRequest
 */
export class UpdateRequest extends Message<UpdateRequest> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * PublicKey is the public key of the node to broadcast to peers.
   *
   * @generated from field: string publicKey = 2;
   */
  publicKey = "";

  /**
   * PrimaryEndpoint is a routable address for the node. If left unset, 
   * the node is assumed to be behind a NAT and not directly accessible.
   *
   * @generated from field: string primaryEndpoint = 3;
   */
  primaryEndpoint = "";

  /**
   * WireguardEndpoints is a list of WireGuard endpoints for the node.
   *
   * @generated from field: repeated string wireguardEndpoints = 4;
   */
  wireguardEndpoints: string[] = [];

  /**
   * ZoneAwarenessID is the zone awareness ID of the node.
   *
   * @generated from field: string zoneAwarenessID = 5;
   */
  zoneAwarenessID = "";

  /**
   * AsVoter is whether the node should receive a vote in elections. The request
   * will be denied if the node is not allowed to vote.
   *
   * @generated from field: bool asVoter = 6;
   */
  asVoter = false;

  /**
   * Routes is a list of routes to advertise to peers. The request will be denied
   * if the node is not allowed to put routes.
   *
   * @generated from field: repeated string routes = 7;
   */
  routes: string[] = [];

  /**
   * Features is a list of features supported by the node that should be advertised to peers
   * and the port they are available on.
   *
   * @generated from field: repeated v1.FeaturePort features = 8;
   */
  features: FeaturePort[] = [];

  /**
   * Multiaddrs are libp2p multiaddresses this node is listening on.
   *
   * @generated from field: repeated string multiaddrs = 9;
   */
  multiaddrs: string[] = [];

  constructor(data?: PartialMessage<UpdateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.UpdateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "publicKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "primaryEndpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "wireguardEndpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "zoneAwarenessID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "asVoter", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "routes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "features", kind: "message", T: FeaturePort, repeated: true },
    { no: 9, name: "multiaddrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateRequest {
    return new UpdateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateRequest {
    return new UpdateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateRequest {
    return new UpdateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateRequest | PlainMessage<UpdateRequest> | undefined, b: UpdateRequest | PlainMessage<UpdateRequest> | undefined): boolean {
    return proto3.util.equals(UpdateRequest, a, b);
  }
}

/**
 * UpdateResponse is a response to an update request. It is currently empty.
 *
 * @generated from message v1.UpdateResponse
 */
export class UpdateResponse extends Message<UpdateResponse> {
  constructor(data?: PartialMessage<UpdateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.UpdateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateResponse {
    return new UpdateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateResponse {
    return new UpdateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateResponse {
    return new UpdateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateResponse | PlainMessage<UpdateResponse> | undefined, b: UpdateResponse | PlainMessage<UpdateResponse> | undefined): boolean {
    return proto3.util.equals(UpdateResponse, a, b);
  }
}

/**
 * WireGuardPeer is a peer in the Wireguard network.
 *
 * @generated from message v1.WireGuardPeer
 */
export class WireGuardPeer extends Message<WireGuardPeer> {
  /**
   * Node is information about this node.
   *
   * @generated from field: v1.MeshNode node = 1;
   */
  node?: MeshNode;

  /**
   * AllowedIPs is the list of allowed IPs for the peer.
   *
   * @generated from field: repeated string allowedIPs = 2;
   */
  allowedIPs: string[] = [];

  /**
   * AllowedRoutes is the list of allowed routes for the peer.
   *
   * @generated from field: repeated string allowedRoutes = 3;
   */
  allowedRoutes: string[] = [];

  /**
   * Proto indicates the protocol to use to connect to the peer.
   *
   * @generated from field: v1.ConnectProtocol proto = 4;
   */
  proto = ConnectProtocol.CONNECT_NATIVE;

  constructor(data?: PartialMessage<WireGuardPeer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.WireGuardPeer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: MeshNode },
    { no: 2, name: "allowedIPs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "allowedRoutes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "proto", kind: "enum", T: proto3.getEnumType(ConnectProtocol) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireGuardPeer {
    return new WireGuardPeer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireGuardPeer {
    return new WireGuardPeer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireGuardPeer {
    return new WireGuardPeer().fromJsonString(jsonString, options);
  }

  static equals(a: WireGuardPeer | PlainMessage<WireGuardPeer> | undefined, b: WireGuardPeer | PlainMessage<WireGuardPeer> | undefined): boolean {
    return proto3.util.equals(WireGuardPeer, a, b);
  }
}

/**
 * LeaveRequest is a request to leave the cluster.
 *
 * @generated from message v1.LeaveRequest
 */
export class LeaveRequest extends Message<LeaveRequest> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<LeaveRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.LeaveRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LeaveRequest {
    return new LeaveRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LeaveRequest {
    return new LeaveRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LeaveRequest {
    return new LeaveRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LeaveRequest | PlainMessage<LeaveRequest> | undefined, b: LeaveRequest | PlainMessage<LeaveRequest> | undefined): boolean {
    return proto3.util.equals(LeaveRequest, a, b);
  }
}

/**
 * LeaveResponse is a response to a leave request. It is currently empty.
 *
 * @generated from message v1.LeaveResponse
 */
export class LeaveResponse extends Message<LeaveResponse> {
  constructor(data?: PartialMessage<LeaveResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.LeaveResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LeaveResponse {
    return new LeaveResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LeaveResponse {
    return new LeaveResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LeaveResponse {
    return new LeaveResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LeaveResponse | PlainMessage<LeaveResponse> | undefined, b: LeaveResponse | PlainMessage<LeaveResponse> | undefined): boolean {
    return proto3.util.equals(LeaveResponse, a, b);
  }
}

/**
 * StorageConsensusRequest is a request to get the current Storage configuration.
 *
 * @generated from message v1.StorageConsensusRequest
 */
export class StorageConsensusRequest extends Message<StorageConsensusRequest> {
  constructor(data?: PartialMessage<StorageConsensusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.StorageConsensusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageConsensusRequest {
    return new StorageConsensusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageConsensusRequest {
    return new StorageConsensusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageConsensusRequest {
    return new StorageConsensusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StorageConsensusRequest | PlainMessage<StorageConsensusRequest> | undefined, b: StorageConsensusRequest | PlainMessage<StorageConsensusRequest> | undefined): boolean {
    return proto3.util.equals(StorageConsensusRequest, a, b);
  }
}

/**
 * StorageConsensusResponse is a response to a Storage consensus request.
 *
 * @generated from message v1.StorageConsensusResponse
 */
export class StorageConsensusResponse extends Message<StorageConsensusResponse> {
  /**
   * Servers is the list of servers in the storage configuration.
   *
   * @generated from field: repeated v1.StorageServer servers = 1;
   */
  servers: StorageServer[] = [];

  constructor(data?: PartialMessage<StorageConsensusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.StorageConsensusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "servers", kind: "message", T: StorageServer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageConsensusResponse {
    return new StorageConsensusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageConsensusResponse {
    return new StorageConsensusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageConsensusResponse {
    return new StorageConsensusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StorageConsensusResponse | PlainMessage<StorageConsensusResponse> | undefined, b: StorageConsensusResponse | PlainMessage<StorageConsensusResponse> | undefined): boolean {
    return proto3.util.equals(StorageConsensusResponse, a, b);
  }
}

/**
 * StorageServer is a server in the Storage configuration.
 *
 * @generated from message v1.StorageServer
 */
export class StorageServer extends Message<StorageServer> {
  /**
   * ID is the ID of the server.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Suffrage is the suffrage of the server.
   *
   * @generated from field: v1.ClusterStatus suffrage = 2;
   */
  suffrage = ClusterStatus.CLUSTER_STATUS_UNKNOWN;

  /**
   * PublicKey is the public key of this server. Not all storage providers track this field.
   *
   * @generated from field: string publicKey = 3;
   */
  publicKey = "";

  /**
   * Address is the mesh address of the server.
   *
   * @generated from field: string address = 4;
   */
  address = "";

  constructor(data?: PartialMessage<StorageServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.StorageServer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "suffrage", kind: "enum", T: proto3.getEnumType(ClusterStatus) },
    { no: 3, name: "publicKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageServer {
    return new StorageServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageServer {
    return new StorageServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageServer {
    return new StorageServer().fromJsonString(jsonString, options);
  }

  static equals(a: StorageServer | PlainMessage<StorageServer> | undefined, b: StorageServer | PlainMessage<StorageServer> | undefined): boolean {
    return proto3.util.equals(StorageServer, a, b);
  }
}

/**
 * SubscribePeersRequest is a request to subscribe to peer updates.
 *
 * @generated from message v1.SubscribePeersRequest
 */
export class SubscribePeersRequest extends Message<SubscribePeersRequest> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<SubscribePeersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.SubscribePeersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribePeersRequest {
    return new SubscribePeersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribePeersRequest {
    return new SubscribePeersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribePeersRequest {
    return new SubscribePeersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubscribePeersRequest | PlainMessage<SubscribePeersRequest> | undefined, b: SubscribePeersRequest | PlainMessage<SubscribePeersRequest> | undefined): boolean {
    return proto3.util.equals(SubscribePeersRequest, a, b);
  }
}

/**
 * PeerConfigurations is a stream of peer configurations.
 *
 * @generated from message v1.PeerConfigurations
 */
export class PeerConfigurations extends Message<PeerConfigurations> {
  /**
   * Peers is a list of wireguard peers to connect to.
   *
   * @generated from field: repeated v1.WireGuardPeer peers = 5;
   */
  peers: WireGuardPeer[] = [];

  /**
   * ICEServers is a list of public nodes that can be used to negotiate
   * ICE connections if required. This may only be populated when one of
   * the peers has the ICE flag set.
   *
   * @generated from field: repeated string iceServers = 6;
   */
  iceServers: string[] = [];

  /**
   * DNSServers is a list of peers offering DNS services.
   *
   * @generated from field: repeated string dnsServers = 7;
   */
  dnsServers: string[] = [];

  constructor(data?: PartialMessage<PeerConfigurations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.PeerConfigurations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "peers", kind: "message", T: WireGuardPeer, repeated: true },
    { no: 6, name: "iceServers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "dnsServers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PeerConfigurations {
    return new PeerConfigurations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PeerConfigurations {
    return new PeerConfigurations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PeerConfigurations {
    return new PeerConfigurations().fromJsonString(jsonString, options);
  }

  static equals(a: PeerConfigurations | PlainMessage<PeerConfigurations> | undefined, b: PeerConfigurations | PlainMessage<PeerConfigurations> | undefined): boolean {
    return proto3.util.equals(PeerConfigurations, a, b);
  }
}

