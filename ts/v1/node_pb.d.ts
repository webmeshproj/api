//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1
// @generated from file v1/node.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * ClusterStatus is the status of the node in the cluster.
 *
 * @generated from enum v1.ClusterStatus
 */
export declare enum ClusterStatus {
  /**
   * CLUSTER_STATUS_UNKNOWN is the default status.
   *
   * @generated from enum value: CLUSTER_STATUS_UNKNOWN = 0;
   */
  CLUSTER_STATUS_UNKNOWN = 0,

  /**
   * CLUSTER_LEADER is the status for the leader node.
   *
   * @generated from enum value: CLUSTER_LEADER = 1;
   */
  CLUSTER_LEADER = 1,

  /**
   * CLUSTER_VOTER is the status for a voter node.
   *
   * @generated from enum value: CLUSTER_VOTER = 2;
   */
  CLUSTER_VOTER = 2,

  /**
   * CLUSTER_OBSERVER is the status for a non-voter node.
   *
   * @generated from enum value: CLUSTER_OBSERVER = 3;
   */
  CLUSTER_OBSERVER = 3,

  /**
   * CLUSTER_NODE is the status of a node that is not a part of the storage consensus.
   *
   * @generated from enum value: CLUSTER_NODE = 4;
   */
  CLUSTER_NODE = 4,
}

/**
 * Feature is a list of features supported by a node.
 *
 * @generated from enum v1.Feature
 */
export declare enum Feature {
  /**
   * FEATURE_NONE is the default feature set.
   *
   * @generated from enum value: FEATURE_NONE = 0;
   */
  FEATURE_NONE = 0,

  /**
   * NODES is the feature for nodes. This is always supported.
   *
   * @generated from enum value: NODES = 1;
   */
  NODES = 1,

  /**
   * LEADER_PROXY is the feature for leader proxying.
   *
   * @generated from enum value: LEADER_PROXY = 2;
   */
  LEADER_PROXY = 2,

  /**
   * MESH_API is the feature for the mesh API.
   * This will be deprecated in favor of the MEMBERSHIP feature.
   *
   * @generated from enum value: MESH_API = 3;
   */
  MESH_API = 3,

  /**
   * ADMIN_API is the feature for the admin API.
   *
   * @generated from enum value: ADMIN_API = 4;
   */
  ADMIN_API = 4,

  /**
   * MEMBERSHIP is the feature for membership. This is always supported on storage-providing members.
   *
   * @generated from enum value: MEMBERSHIP = 5;
   */
  MEMBERSHIP = 5,

  /**
   * METRICS is the feature for exposing metrics.
   *
   * @generated from enum value: METRICS = 6;
   */
  METRICS = 6,

  /**
   * ICE_NEGOTIATION is the feature for ICE negotiation.
   *
   * @generated from enum value: ICE_NEGOTIATION = 7;
   */
  ICE_NEGOTIATION = 7,

  /**
   * TURN_SERVER is the feature for TURN server.
   *
   * @generated from enum value: TURN_SERVER = 8;
   */
  TURN_SERVER = 8,

  /**
   * MESH_DNS is the feature for mesh DNS.
   *
   * @generated from enum value: MESH_DNS = 9;
   */
  MESH_DNS = 9,

  /**
   * FORWARD_MESH_DNS is the feature for forwarding mesh DNS lookups to other meshes.
   *
   * @generated from enum value: FORWARD_MESH_DNS = 10;
   */
  FORWARD_MESH_DNS = 10,

  /**
   * STORAGE_QUERIER is the feature for querying, publishing, and subscribing to mesh state.
   *
   * @generated from enum value: STORAGE_QUERIER = 11;
   */
  STORAGE_QUERIER = 11,

  /**
   * STORAGE_PROVIDER is the feature for being able to provide distributed storage.
   *
   * @generated from enum value: STORAGE_PROVIDER = 12;
   */
  STORAGE_PROVIDER = 12,

  /**
   * REGISTRAR is the feature for being able to register aliases to node IDs and/or public keys.
   *
   * @generated from enum value: REGISTRAR = 13;
   */
  REGISTRAR = 13,
}

/**
 * EdgeAttribute are pre-defined edge attributes. They should
 * be used as their string values.
 *
 * @generated from enum v1.EdgeAttribute
 */
export declare enum EdgeAttribute {
  /**
   * EDGE_ATTRIBUTE_UNKNOWN is an unknown edge attribute.
   *
   * @generated from enum value: EDGE_ATTRIBUTE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * EDGE_ATTRIBUTE_NATIVE is a native edge attribute.
   *
   * @generated from enum value: EDGE_ATTRIBUTE_NATIVE = 1;
   */
  NATIVE = 1,

  /**
   * EDGE_ATTRIBUTE_ICE is an ICE edge attribute.
   *
   * @generated from enum value: EDGE_ATTRIBUTE_ICE = 2;
   */
  ICE = 2,

  /**
   * EDGE_ATTRIBUTE_LIBP2P is a libp2p edge attribute.
   *
   * @generated from enum value: EDGE_ATTRIBUTE_LIBP2P = 3;
   */
  LIBP2P = 3,
}

/**
 * DataChannel are the data channels used when communicating over ICE
 * with a node.
 *
 * @generated from enum v1.DataChannel
 */
export declare enum DataChannel {
  /**
   * CHANNELS is the data channel used for negotiating new channels.
   * This is the first channel that is opened. The ID of the channel
   * should be 0.
   *
   * @generated from enum value: CHANNELS = 0;
   */
  CHANNELS = 0,

  /**
   * CONNECTIONS is the data channel used for negotiating new connections.
   * This is a channel that is opened for each incoming connection from a
   * client. The ID should start at 0 and be incremented for each new connection.
   *
   * @generated from enum value: CONNECTIONS = 1;
   */
  CONNECTIONS = 1,
}

/**
 * FeaturePort describes a feature and the port it is advertised on.
 *
 * @generated from message v1.FeaturePort
 */
export declare class FeaturePort extends Message<FeaturePort> {
  /**
   * Feature is the feature advertised on the port.
   *
   * @generated from field: v1.Feature feature = 1;
   */
  feature: Feature;

  /**
   * Port is the port the feature is advertised on.
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  constructor(data?: PartialMessage<FeaturePort>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.FeaturePort";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeaturePort;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeaturePort;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeaturePort;

  static equals(a: FeaturePort | PlainMessage<FeaturePort> | undefined, b: FeaturePort | PlainMessage<FeaturePort> | undefined): boolean;
}

/**
 * MeshNode is a node that has been registered with the mesh.
 *
 * @generated from message v1.MeshNode
 */
export declare class MeshNode extends Message<MeshNode> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * PublicKey is the public key of the node.
   *
   * @generated from field: string publicKey = 2;
   */
  publicKey: string;

  /**
   * PrimaryEndpoint is the primary endpoint of the node.
   *
   * @generated from field: string primaryEndpoint = 4;
   */
  primaryEndpoint: string;

  /**
   * WireguardEndpoints is a list of WireGuard endpoints for the node.
   *
   * @generated from field: repeated string wireguardEndpoints = 5;
   */
  wireguardEndpoints: string[];

  /**
   * ZoneAwarenessID is the zone awareness ID of the node.
   *
   * @generated from field: string zoneAwarenessID = 6;
   */
  zoneAwarenessID: string;

  /**
   * PrivateIPv4 is the private IPv4 address of the node.
   *
   * @generated from field: string privateIPv4 = 7;
   */
  privateIPv4: string;

  /**
   * PrivateIPv6 is the private IPv6 address of the node.
   *
   * @generated from field: string privateIPv6 = 8;
   */
  privateIPv6: string;

  /**
   * Features are a list of features and the ports they are advertised on.
   *
   * @generated from field: repeated v1.FeaturePort features = 9;
   */
  features: FeaturePort[];

  /**
   * Multiaddrs are the multiaddrs of the node.
   *
   * @generated from field: repeated string multiaddrs = 10;
   */
  multiaddrs: string[];

  /**
   * JoinedAt is the time the node joined the cluster.
   *
   * @generated from field: google.protobuf.Timestamp joinedAt = 11;
   */
  joinedAt?: Timestamp;

  constructor(data?: PartialMessage<MeshNode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.MeshNode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshNode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshNode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshNode;

  static equals(a: MeshNode | PlainMessage<MeshNode> | undefined, b: MeshNode | PlainMessage<MeshNode> | undefined): boolean;
}

/**
 * NodeList is a list of nodes.
 *
 * @generated from message v1.NodeList
 */
export declare class NodeList extends Message<NodeList> {
  /**
   * Nodes is the list of nodes.
   *
   * @generated from field: repeated v1.MeshNode nodes = 1;
   */
  nodes: MeshNode[];

  constructor(data?: PartialMessage<NodeList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.NodeList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeList;

  static equals(a: NodeList | PlainMessage<NodeList> | undefined, b: NodeList | PlainMessage<NodeList> | undefined): boolean;
}

/**
 * GetStatusRequest is a request to get the status of a node.
 *
 * @generated from message v1.GetStatusRequest
 */
export declare class GetStatusRequest extends Message<GetStatusRequest> {
  /**
   * ID is the ID of the node. If unset, the status of the local node is returned.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  constructor(data?: PartialMessage<GetStatusRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.GetStatusRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatusRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatusRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatusRequest;

  static equals(a: GetStatusRequest | PlainMessage<GetStatusRequest> | undefined, b: GetStatusRequest | PlainMessage<GetStatusRequest> | undefined): boolean;
}

/**
 * Status represents the status of a node.
 *
 * @generated from message v1.Status
 */
export declare class Status extends Message<Status> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Description is an optional description provided
   * by the node.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Version is the version of the node.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * GitCommit is the git commit of the node.
   *
   * @generated from field: string gitCommit = 4;
   */
  gitCommit: string;

  /**
   * BuildDate is the build date of the node.
   *
   * @generated from field: string buildDate = 5;
   */
  buildDate: string;

  /**
   * Uptime is the uptime of the node.
   *
   * @generated from field: string uptime = 6;
   */
  uptime: string;

  /**
   * StartedAt is the time the node started.
   *
   * @generated from field: google.protobuf.Timestamp startedAt = 7;
   */
  startedAt?: Timestamp;

  /**
   * Features is the list of features currently enabled.
   *
   * @generated from field: repeated v1.FeaturePort features = 8;
   */
  features: FeaturePort[];

  /**
   * ClusterStatus is the status of the node in the cluster.
   *
   * @generated from field: v1.ClusterStatus clusterStatus = 9;
   */
  clusterStatus: ClusterStatus;

  /**
   * CurrentLeader is the current leader of the cluster.
   *
   * @generated from field: string currentLeader = 10;
   */
  currentLeader: string;

  /**
   * InterfaceMetrics are the metrics for the node's interfaces.
   *
   * @generated from field: v1.InterfaceMetrics interfaceMetrics = 11;
   */
  interfaceMetrics?: InterfaceMetrics;

  constructor(data?: PartialMessage<Status>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Status";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Status;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Status;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Status;

  static equals(a: Status | PlainMessage<Status> | undefined, b: Status | PlainMessage<Status> | undefined): boolean;
}

/**
 * DataChannelNegotiation is the message for communicating data channels to nodes.
 *
 * @generated from message v1.DataChannelNegotiation
 */
export declare class DataChannelNegotiation extends Message<DataChannelNegotiation> {
  /**
   * Proto is the protocol of the traffic.
   *
   * @generated from field: string proto = 1;
   */
  proto: string;

  /**
   * Src is the address of the client that initiated the request.
   *
   * @generated from field: string src = 2;
   */
  src: string;

  /**
   * Dst is the destination address of the traffic.
   *
   * @generated from field: string dst = 3;
   */
  dst: string;

  /**
   * Port is the destination port of the traffic.
   *
   * @generated from field: uint32 port = 4;
   */
  port: number;

  /**
   * Offer is the offer for the node to use as its local description.
   *
   * @generated from field: string offer = 5;
   */
  offer: string;

  /**
   * Answer is the answer for the node to use as its remote description.
   *
   * @generated from field: string answer = 6;
   */
  answer: string;

  /**
   * Candidate is an ICE candidate.
   *
   * @generated from field: string candidate = 7;
   */
  candidate: string;

  /**
   * StunServers is the list of STUN servers to use.
   *
   * @generated from field: repeated string stunServers = 8;
   */
  stunServers: string[];

  constructor(data?: PartialMessage<DataChannelNegotiation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.DataChannelNegotiation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataChannelNegotiation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataChannelNegotiation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataChannelNegotiation;

  static equals(a: DataChannelNegotiation | PlainMessage<DataChannelNegotiation> | undefined, b: DataChannelNegotiation | PlainMessage<DataChannelNegotiation> | undefined): boolean;
}

/**
 * InterfaceMetrics is the metrics for the WireGuard interface on a node.
 *
 * @generated from message v1.InterfaceMetrics
 */
export declare class InterfaceMetrics extends Message<InterfaceMetrics> {
  /**
   * DeviceName is the name of the device.
   *
   * @generated from field: string deviceName = 1;
   */
  deviceName: string;

  /**
   * PublicKey is the public key of the node.
   *
   * @generated from field: string publicKey = 2;
   */
  publicKey: string;

  /**
   * AddressV4 is the IPv4 address of the node.
   *
   * @generated from field: string addressV4 = 3;
   */
  addressV4: string;

  /**
   * AddressV6 is the IPv6 address of the node.
   *
   * @generated from field: string addressV6 = 4;
   */
  addressV6: string;

  /**
   * Type is the type of interface being used for wireguard.
   *
   * @generated from field: string type = 5;
   */
  type: string;

  /**
   * ListenPort is the port wireguard is listening on.
   *
   * @generated from field: int32 listenPort = 6;
   */
  listenPort: number;

  /**
   * TotalReceiveBytes is the total number of bytes received.
   *
   * @generated from field: uint64 totalReceiveBytes = 7;
   */
  totalReceiveBytes: bigint;

  /**
   * TotalTransmitBytes is the total number of bytes transmitted.
   *
   * @generated from field: uint64 totalTransmitBytes = 8;
   */
  totalTransmitBytes: bigint;

  /**
   * NumPeers is the number of peers connected to the node.
   *
   * @generated from field: int32 numPeers = 9;
   */
  numPeers: number;

  /**
   * Peers are the per-peer statistics.
   *
   * @generated from field: repeated v1.PeerMetrics peers = 10;
   */
  peers: PeerMetrics[];

  constructor(data?: PartialMessage<InterfaceMetrics>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.InterfaceMetrics";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InterfaceMetrics;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InterfaceMetrics;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InterfaceMetrics;

  static equals(a: InterfaceMetrics | PlainMessage<InterfaceMetrics> | undefined, b: InterfaceMetrics | PlainMessage<InterfaceMetrics> | undefined): boolean;
}

/**
 * PeerMetrics are the metrics for a node's peer.
 *
 * @generated from message v1.PeerMetrics
 */
export declare class PeerMetrics extends Message<PeerMetrics> {
  /**
   * PublicKey is the public key of the peer.
   *
   * @generated from field: string publicKey = 1;
   */
  publicKey: string;

  /**
   * Endpoint is the connected endpoint of the peer.
   *
   * @generated from field: string endpoint = 2;
   */
  endpoint: string;

  /**
   * PersistentKeepAlive is the persistent keep alive interval for the peer.
   *
   * @generated from field: string persistentKeepAlive = 3;
   */
  persistentKeepAlive: string;

  /**
   * LastHandshakeTime is the last handshake time for the peer.
   *
   * @generated from field: string lastHandshakeTime = 4;
   */
  lastHandshakeTime: string;

  /**
   * AllowedIPs is the list of allowed IPs for the peer.
   *
   * @generated from field: repeated string allowedIPs = 5;
   */
  allowedIPs: string[];

  /**
   * ProtocolVersion is the version of the wireguard protocol negotiated with the peer.
   *
   * @generated from field: int64 protocolVersion = 6;
   */
  protocolVersion: bigint;

  /**
   * ReceiveBytes is the bytes received from the peer.
   *
   * @generated from field: uint64 receiveBytes = 7;
   */
  receiveBytes: bigint;

  /**
   * TransmitBytes is the bytes transmitted to the peer.
   *
   * @generated from field: uint64 transmitBytes = 8;
   */
  transmitBytes: bigint;

  constructor(data?: PartialMessage<PeerMetrics>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.PeerMetrics";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PeerMetrics;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PeerMetrics;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PeerMetrics;

  static equals(a: PeerMetrics | PlainMessage<PeerMetrics> | undefined, b: PeerMetrics | PlainMessage<PeerMetrics> | undefined): boolean;
}

/**
 * WebRTCSignal is a signal sent to a remote peer over the WebRTC API.
 *
 * @generated from message v1.WebRTCSignal
 */
export declare class WebRTCSignal extends Message<WebRTCSignal> {
  /**
   * NodeID is the ID of the node to send the signal to.
   * This is set by the original sender. On the node that
   * receives the ReceiveSignalChannel request, this will
   * be set to the ID of the node that sent the request.
   *
   * @generated from field: string nodeID = 1;
   */
  nodeID: string;

  /**
   * Candidate is an ICE candidate.
   *
   * @generated from field: string candidate = 2;
   */
  candidate: string;

  /**
   * Description is a session description.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  constructor(data?: PartialMessage<WebRTCSignal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.WebRTCSignal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebRTCSignal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebRTCSignal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebRTCSignal;

  static equals(a: WebRTCSignal | PlainMessage<WebRTCSignal> | undefined, b: WebRTCSignal | PlainMessage<WebRTCSignal> | undefined): boolean;
}

