//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1
// @generated from file v1/rbac.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * RuleResource is the resource type for a rule.
 *
 * @generated from enum v1.RuleResource
 */
export declare enum RuleResource {
  /**
   * RESOURCE_UNKNOWN is an unknown resource.
   *
   * @generated from enum value: RESOURCE_UNKNOWN = 0;
   */
  RESOURCE_UNKNOWN = 0,

  /**
   * RESOURCE_VOTES is the resource for voting in storage elections. The only
   * verb evaluated for this resource is PUT.
   *
   * @generated from enum value: RESOURCE_VOTES = 1;
   */
  RESOURCE_VOTES = 1,

  /**
   * RESOURCE_ROLES is the resource for managing roles.
   *
   * @generated from enum value: RESOURCE_ROLES = 2;
   */
  RESOURCE_ROLES = 2,

  /**
   * RESOURCE_ROLE_BINDINGS is the resource for managing role bindings.
   *
   * @generated from enum value: RESOURCE_ROLE_BINDINGS = 3;
   */
  RESOURCE_ROLE_BINDINGS = 3,

  /**
   * RESOURCE_GROUPS is the resource for managing groups.
   *
   * @generated from enum value: RESOURCE_GROUPS = 4;
   */
  RESOURCE_GROUPS = 4,

  /**
   * RESOURCE_NETWORK_ACLS is the resource for managing network ACLs.
   *
   * @generated from enum value: RESOURCE_NETWORK_ACLS = 5;
   */
  RESOURCE_NETWORK_ACLS = 5,

  /**
   * RESOURCE_ROUTES is the resource for managing routes.
   *
   * @generated from enum value: RESOURCE_ROUTES = 6;
   */
  RESOURCE_ROUTES = 6,

  /**
   * RESOURCE_DATA_CHANNELS is the resource for creating data channels.
   *
   * @generated from enum value: RESOURCE_DATA_CHANNELS = 7;
   */
  RESOURCE_DATA_CHANNELS = 7,

  /**
   * RESOURCE_EDGES is the resource for managing edges between nodes.
   *
   * @generated from enum value: RESOURCE_EDGES = 8;
   */
  RESOURCE_EDGES = 8,

  /**
   * RESOURCE_OBSERVERS is the resource for managing observers. The only
   * verb evaluated for this resource is PUT.
   *
   * @generated from enum value: RESOURCE_OBSERVERS = 9;
   */
  RESOURCE_OBSERVERS = 9,

  /**
   * RESOURCE_PUBSUB is the resource for managing pubsub topics.
   *
   * @generated from enum value: RESOURCE_PUBSUB = 10;
   */
  RESOURCE_PUBSUB = 10,

  /**
   * RESOURCE_ALL is a wildcard resource that matches all resources.
   *
   * @generated from enum value: RESOURCE_ALL = 999;
   */
  RESOURCE_ALL = 999,
}

/**
 * RuleVerb is the verb type for a rule.
 *
 * @generated from enum v1.RuleVerb
 */
export declare enum RuleVerb {
  /**
   * VERB_UNKNOWN is an unknown verb.
   *
   * @generated from enum value: VERB_UNKNOWN = 0;
   */
  VERB_UNKNOWN = 0,

  /**
   * VERB_PUT is the verb for creating or updating a resource.
   *
   * @generated from enum value: VERB_PUT = 1;
   */
  VERB_PUT = 1,

  /**
   * VERB_GET is the verb for getting a resource.
   *
   * @generated from enum value: VERB_GET = 2;
   */
  VERB_GET = 2,

  /**
   * VERB_DELETE is the verb for deleting a resource.
   *
   * @generated from enum value: VERB_DELETE = 3;
   */
  VERB_DELETE = 3,

  /**
   * VERB_ALL is a wildcard verb that matches all verbs.
   *
   * @generated from enum value: VERB_ALL = 999;
   */
  VERB_ALL = 999,
}

/**
 * SubjectType is the type of a subject.
 *
 * @generated from enum v1.SubjectType
 */
export declare enum SubjectType {
  /**
   * SUBJECT_UNKNOWN is an unknown subject type.
   *
   * @generated from enum value: SUBJECT_UNKNOWN = 0;
   */
  SUBJECT_UNKNOWN = 0,

  /**
   * SUBJECT_NODE is a subject type for a node.
   *
   * @generated from enum value: SUBJECT_NODE = 1;
   */
  SUBJECT_NODE = 1,

  /**
   * SUBJECT_USER is a subject type for a user.
   *
   * @generated from enum value: SUBJECT_USER = 2;
   */
  SUBJECT_USER = 2,

  /**
   * SUBJECT_GROUP is a subject type for a group.
   *
   * @generated from enum value: SUBJECT_GROUP = 3;
   */
  SUBJECT_GROUP = 3,

  /**
   * SUBJECT_ALL is a wildcard subject type that matches all subject types.
   * It can be used with a subject named '*' to match all subjects.
   *
   * @generated from enum value: SUBJECT_ALL = 999;
   */
  SUBJECT_ALL = 999,
}

/**
 * Rule is a rule that applies to a resource.
 *
 * @generated from message v1.Rule
 */
export declare class Rule extends Message<Rule> {
  /**
   * Resources is the resources to which the rule applies.
   *
   * @generated from field: repeated v1.RuleResource resources = 1;
   */
  resources: RuleResource[];

  /**
   * ResourceNames is the list of resource names to which the rule applies.
   *
   * @generated from field: repeated string resourceNames = 2;
   */
  resourceNames: string[];

  /**
   * Verbs is the list of verbs that apply to the resource.
   *
   * @generated from field: repeated v1.RuleVerb verbs = 3;
   */
  verbs: RuleVerb[];

  constructor(data?: PartialMessage<Rule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Rule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule;

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean;
}

/**
 * Role is a role that can be assigned to a subject.
 *
 * @generated from message v1.Role
 */
export declare class Role extends Message<Role> {
  /**
   * Name is the name of the role.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Rules is the list of rules that apply to the role.
   *
   * @generated from field: repeated v1.Rule rules = 2;
   */
  rules: Rule[];

  constructor(data?: PartialMessage<Role>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Role";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Role;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Role;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Role;

  static equals(a: Role | PlainMessage<Role> | undefined, b: Role | PlainMessage<Role> | undefined): boolean;
}

/**
 * Roles is a list of roles.
 *
 * @generated from message v1.Roles
 */
export declare class Roles extends Message<Roles> {
  /**
   * Items is the list of roles.
   *
   * @generated from field: repeated v1.Role items = 1;
   */
  items: Role[];

  constructor(data?: PartialMessage<Roles>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Roles";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Roles;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Roles;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Roles;

  static equals(a: Roles | PlainMessage<Roles> | undefined, b: Roles | PlainMessage<Roles> | undefined): boolean;
}

/**
 * RoleBinding is a binding of a role to one or more subjects.
 *
 * @generated from message v1.RoleBinding
 */
export declare class RoleBinding extends Message<RoleBinding> {
  /**
   * Name is the name of the role binding.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Role is the name of the role to which the binding applies.
   *
   * @generated from field: string role = 2;
   */
  role: string;

  /**
   * Subjects is the list of subjects to which the binding applies.
   *
   * @generated from field: repeated v1.Subject subjects = 3;
   */
  subjects: Subject[];

  constructor(data?: PartialMessage<RoleBinding>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.RoleBinding";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBinding;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBinding;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBinding;

  static equals(a: RoleBinding | PlainMessage<RoleBinding> | undefined, b: RoleBinding | PlainMessage<RoleBinding> | undefined): boolean;
}

/**
 * RoleBindings is a list of role bindings.
 *
 * @generated from message v1.RoleBindings
 */
export declare class RoleBindings extends Message<RoleBindings> {
  /**
   * Items is the list of role bindings.
   *
   * @generated from field: repeated v1.RoleBinding items = 1;
   */
  items: RoleBinding[];

  constructor(data?: PartialMessage<RoleBindings>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.RoleBindings";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBindings;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBindings;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBindings;

  static equals(a: RoleBindings | PlainMessage<RoleBindings> | undefined, b: RoleBindings | PlainMessage<RoleBindings> | undefined): boolean;
}

/**
 * Subject is a subject to which a role can be bound.
 *
 * @generated from message v1.Subject
 */
export declare class Subject extends Message<Subject> {
  /**
   * Name is the name of the subject.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Type is the type of the subject.
   *
   * @generated from field: v1.SubjectType type = 2;
   */
  type: SubjectType;

  constructor(data?: PartialMessage<Subject>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Subject";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subject;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subject;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subject;

  static equals(a: Subject | PlainMessage<Subject> | undefined, b: Subject | PlainMessage<Subject> | undefined): boolean;
}

/**
 * Group is a group of subjects.
 *
 * @generated from message v1.Group
 */
export declare class Group extends Message<Group> {
  /**
   * Name is the name of the group.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Subjects is the list of subjects in the group.
   *
   * @generated from field: repeated v1.Subject subjects = 2;
   */
  subjects: Subject[];

  constructor(data?: PartialMessage<Group>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Group";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Group;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Group;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Group;

  static equals(a: Group | PlainMessage<Group> | undefined, b: Group | PlainMessage<Group> | undefined): boolean;
}

/**
 * Groups is a list of groups.
 *
 * @generated from message v1.Groups
 */
export declare class Groups extends Message<Groups> {
  /**
   * Items is the list of groups.
   *
   * @generated from field: repeated v1.Group items = 1;
   */
  items: Group[];

  constructor(data?: PartialMessage<Groups>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.Groups";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Groups;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Groups;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Groups;

  static equals(a: Groups | PlainMessage<Groups> | undefined, b: Groups | PlainMessage<Groups> | undefined): boolean;
}

/**
 * RBACAction is an action that can be performed on a resource. It is used by implementations
 * to evaluate rules.
 *
 * @generated from message v1.RBACAction
 */
export declare class RBACAction extends Message<RBACAction> {
  /**
   * Resource is the resource on which the action is performed.
   *
   * @generated from field: v1.RuleResource resource = 1;
   */
  resource: RuleResource;

  /**
   * ResourceName is the name of the resource on which the action is
   * performed.
   *
   * @generated from field: string resourceName = 2;
   */
  resourceName: string;

  /**
   * Verb is the verb that is performed on the resource.
   *
   * @generated from field: v1.RuleVerb verb = 3;
   */
  verb: RuleVerb;

  constructor(data?: PartialMessage<RBACAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.RBACAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RBACAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RBACAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RBACAction;

  static equals(a: RBACAction | PlainMessage<RBACAction> | undefined, b: RBACAction | PlainMessage<RBACAction> | undefined): boolean;
}

