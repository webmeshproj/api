//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file v1/rbac.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * RuleResource is the resource type for a rule.
 *
 * @generated from enum v1.RuleResource
 */
export enum RuleResource {
  /**
   * RESOURCE_UNKNOWN is an unknown resource.
   *
   * @generated from enum value: RESOURCE_UNKNOWN = 0;
   */
  RESOURCE_UNKNOWN = 0,

  /**
   * RESOURCE_VOTES is the resource for voting in storage elections. The only
   * verb evaluated for this resource is PUT.
   *
   * @generated from enum value: RESOURCE_VOTES = 1;
   */
  RESOURCE_VOTES = 1,

  /**
   * RESOURCE_ROLES is the resource for managing roles.
   *
   * @generated from enum value: RESOURCE_ROLES = 2;
   */
  RESOURCE_ROLES = 2,

  /**
   * RESOURCE_ROLE_BINDINGS is the resource for managing role bindings.
   *
   * @generated from enum value: RESOURCE_ROLE_BINDINGS = 3;
   */
  RESOURCE_ROLE_BINDINGS = 3,

  /**
   * RESOURCE_GROUPS is the resource for managing groups.
   *
   * @generated from enum value: RESOURCE_GROUPS = 4;
   */
  RESOURCE_GROUPS = 4,

  /**
   * RESOURCE_NETWORK_ACLS is the resource for managing network ACLs.
   *
   * @generated from enum value: RESOURCE_NETWORK_ACLS = 5;
   */
  RESOURCE_NETWORK_ACLS = 5,

  /**
   * RESOURCE_ROUTES is the resource for managing routes.
   *
   * @generated from enum value: RESOURCE_ROUTES = 6;
   */
  RESOURCE_ROUTES = 6,

  /**
   * RESOURCE_DATA_CHANNELS is the resource for creating data channels.
   *
   * @generated from enum value: RESOURCE_DATA_CHANNELS = 7;
   */
  RESOURCE_DATA_CHANNELS = 7,

  /**
   * RESOURCE_EDGES is the resource for managing edges between nodes.
   *
   * @generated from enum value: RESOURCE_EDGES = 8;
   */
  RESOURCE_EDGES = 8,

  /**
   * RESOURCE_OBSERVERS is the resource for managing observers. The only
   * verb evaluated for this resource is PUT.
   *
   * @generated from enum value: RESOURCE_OBSERVERS = 9;
   */
  RESOURCE_OBSERVERS = 9,

  /**
   * RESOURCE_PUBSUB is the resource for managing pubsub topics.
   *
   * @generated from enum value: RESOURCE_PUBSUB = 10;
   */
  RESOURCE_PUBSUB = 10,

  /**
   * RESOURCE_ALL is a wildcard resource that matches all resources.
   *
   * @generated from enum value: RESOURCE_ALL = 999;
   */
  RESOURCE_ALL = 999,
}
// Retrieve enum metadata with: proto3.getEnumType(RuleResource)
proto3.util.setEnumType(RuleResource, "v1.RuleResource", [
  { no: 0, name: "RESOURCE_UNKNOWN" },
  { no: 1, name: "RESOURCE_VOTES" },
  { no: 2, name: "RESOURCE_ROLES" },
  { no: 3, name: "RESOURCE_ROLE_BINDINGS" },
  { no: 4, name: "RESOURCE_GROUPS" },
  { no: 5, name: "RESOURCE_NETWORK_ACLS" },
  { no: 6, name: "RESOURCE_ROUTES" },
  { no: 7, name: "RESOURCE_DATA_CHANNELS" },
  { no: 8, name: "RESOURCE_EDGES" },
  { no: 9, name: "RESOURCE_OBSERVERS" },
  { no: 10, name: "RESOURCE_PUBSUB" },
  { no: 999, name: "RESOURCE_ALL" },
]);

/**
 * RuleVerb is the verb type for a rule.
 *
 * @generated from enum v1.RuleVerb
 */
export enum RuleVerb {
  /**
   * VERB_UNKNOWN is an unknown verb.
   *
   * @generated from enum value: VERB_UNKNOWN = 0;
   */
  VERB_UNKNOWN = 0,

  /**
   * VERB_PUT is the verb for creating or updating a resource.
   *
   * @generated from enum value: VERB_PUT = 1;
   */
  VERB_PUT = 1,

  /**
   * VERB_GET is the verb for getting a resource.
   *
   * @generated from enum value: VERB_GET = 2;
   */
  VERB_GET = 2,

  /**
   * VERB_DELETE is the verb for deleting a resource.
   *
   * @generated from enum value: VERB_DELETE = 3;
   */
  VERB_DELETE = 3,

  /**
   * VERB_ALL is a wildcard verb that matches all verbs.
   *
   * @generated from enum value: VERB_ALL = 999;
   */
  VERB_ALL = 999,
}
// Retrieve enum metadata with: proto3.getEnumType(RuleVerb)
proto3.util.setEnumType(RuleVerb, "v1.RuleVerb", [
  { no: 0, name: "VERB_UNKNOWN" },
  { no: 1, name: "VERB_PUT" },
  { no: 2, name: "VERB_GET" },
  { no: 3, name: "VERB_DELETE" },
  { no: 999, name: "VERB_ALL" },
]);

/**
 * SubjectType is the type of a subject.
 *
 * @generated from enum v1.SubjectType
 */
export enum SubjectType {
  /**
   * SUBJECT_UNKNOWN is an unknown subject type.
   *
   * @generated from enum value: SUBJECT_UNKNOWN = 0;
   */
  SUBJECT_UNKNOWN = 0,

  /**
   * SUBJECT_NODE is a subject type for a node.
   *
   * @generated from enum value: SUBJECT_NODE = 1;
   */
  SUBJECT_NODE = 1,

  /**
   * SUBJECT_USER is a subject type for a user.
   *
   * @generated from enum value: SUBJECT_USER = 2;
   */
  SUBJECT_USER = 2,

  /**
   * SUBJECT_GROUP is a subject type for a group.
   *
   * @generated from enum value: SUBJECT_GROUP = 3;
   */
  SUBJECT_GROUP = 3,

  /**
   * SUBJECT_ALL is a wildcard subject type that matches all subject types.
   * It can be used with a subject named '*' to match all subjects.
   *
   * @generated from enum value: SUBJECT_ALL = 999;
   */
  SUBJECT_ALL = 999,
}
// Retrieve enum metadata with: proto3.getEnumType(SubjectType)
proto3.util.setEnumType(SubjectType, "v1.SubjectType", [
  { no: 0, name: "SUBJECT_UNKNOWN" },
  { no: 1, name: "SUBJECT_NODE" },
  { no: 2, name: "SUBJECT_USER" },
  { no: 3, name: "SUBJECT_GROUP" },
  { no: 999, name: "SUBJECT_ALL" },
]);

/**
 * Rule is a rule that applies to a resource.
 *
 * @generated from message v1.Rule
 */
export class Rule extends Message<Rule> {
  /**
   * Resources is the resources to which the rule applies.
   *
   * @generated from field: repeated v1.RuleResource resources = 1;
   */
  resources: RuleResource[] = [];

  /**
   * ResourceNames is the list of resource names to which the rule applies.
   *
   * @generated from field: repeated string resourceNames = 2;
   */
  resourceNames: string[] = [];

  /**
   * Verbs is the list of verbs that apply to the resource.
   *
   * @generated from field: repeated v1.RuleVerb verbs = 3;
   */
  verbs: RuleVerb[] = [];

  constructor(data?: PartialMessage<Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resources", kind: "enum", T: proto3.getEnumType(RuleResource), repeated: true },
    { no: 2, name: "resourceNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "verbs", kind: "enum", T: proto3.getEnumType(RuleVerb), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
    return new Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJsonString(jsonString, options);
  }

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean {
    return proto3.util.equals(Rule, a, b);
  }
}

/**
 * Role is a role that can be assigned to a subject.
 *
 * @generated from message v1.Role
 */
export class Role extends Message<Role> {
  /**
   * Name is the name of the role.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Rules is the list of rules that apply to the role.
   *
   * @generated from field: repeated v1.Rule rules = 2;
   */
  rules: Rule[] = [];

  constructor(data?: PartialMessage<Role>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Role";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rules", kind: "message", T: Rule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Role {
    return new Role().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJsonString(jsonString, options);
  }

  static equals(a: Role | PlainMessage<Role> | undefined, b: Role | PlainMessage<Role> | undefined): boolean {
    return proto3.util.equals(Role, a, b);
  }
}

/**
 * Roles is a list of roles.
 *
 * @generated from message v1.Roles
 */
export class Roles extends Message<Roles> {
  /**
   * Items is the list of roles.
   *
   * @generated from field: repeated v1.Role items = 1;
   */
  items: Role[] = [];

  constructor(data?: PartialMessage<Roles>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Roles";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Role, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Roles {
    return new Roles().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Roles {
    return new Roles().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Roles {
    return new Roles().fromJsonString(jsonString, options);
  }

  static equals(a: Roles | PlainMessage<Roles> | undefined, b: Roles | PlainMessage<Roles> | undefined): boolean {
    return proto3.util.equals(Roles, a, b);
  }
}

/**
 * RoleBinding is a binding of a role to one or more subjects.
 *
 * @generated from message v1.RoleBinding
 */
export class RoleBinding extends Message<RoleBinding> {
  /**
   * Name is the name of the role binding.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Role is the name of the role to which the binding applies.
   *
   * @generated from field: string role = 2;
   */
  role = "";

  /**
   * Subjects is the list of subjects to which the binding applies.
   *
   * @generated from field: repeated v1.Subject subjects = 3;
   */
  subjects: Subject[] = [];

  constructor(data?: PartialMessage<RoleBinding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.RoleBinding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subjects", kind: "message", T: Subject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBinding {
    return new RoleBinding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBinding {
    return new RoleBinding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBinding {
    return new RoleBinding().fromJsonString(jsonString, options);
  }

  static equals(a: RoleBinding | PlainMessage<RoleBinding> | undefined, b: RoleBinding | PlainMessage<RoleBinding> | undefined): boolean {
    return proto3.util.equals(RoleBinding, a, b);
  }
}

/**
 * RoleBindings is a list of role bindings.
 *
 * @generated from message v1.RoleBindings
 */
export class RoleBindings extends Message<RoleBindings> {
  /**
   * Items is the list of role bindings.
   *
   * @generated from field: repeated v1.RoleBinding items = 1;
   */
  items: RoleBinding[] = [];

  constructor(data?: PartialMessage<RoleBindings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.RoleBindings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: RoleBinding, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBindings {
    return new RoleBindings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBindings {
    return new RoleBindings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBindings {
    return new RoleBindings().fromJsonString(jsonString, options);
  }

  static equals(a: RoleBindings | PlainMessage<RoleBindings> | undefined, b: RoleBindings | PlainMessage<RoleBindings> | undefined): boolean {
    return proto3.util.equals(RoleBindings, a, b);
  }
}

/**
 * Subject is a subject to which a role can be bound.
 *
 * @generated from message v1.Subject
 */
export class Subject extends Message<Subject> {
  /**
   * Name is the name of the subject.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Type is the type of the subject.
   *
   * @generated from field: v1.SubjectType type = 2;
   */
  type = SubjectType.SUBJECT_UNKNOWN;

  constructor(data?: PartialMessage<Subject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Subject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(SubjectType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subject {
    return new Subject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subject {
    return new Subject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subject {
    return new Subject().fromJsonString(jsonString, options);
  }

  static equals(a: Subject | PlainMessage<Subject> | undefined, b: Subject | PlainMessage<Subject> | undefined): boolean {
    return proto3.util.equals(Subject, a, b);
  }
}

/**
 * Group is a group of subjects.
 *
 * @generated from message v1.Group
 */
export class Group extends Message<Group> {
  /**
   * Name is the name of the group.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Subjects is the list of subjects in the group.
   *
   * @generated from field: repeated v1.Subject subjects = 2;
   */
  subjects: Subject[] = [];

  constructor(data?: PartialMessage<Group>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Group";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subjects", kind: "message", T: Subject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Group {
    return new Group().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJsonString(jsonString, options);
  }

  static equals(a: Group | PlainMessage<Group> | undefined, b: Group | PlainMessage<Group> | undefined): boolean {
    return proto3.util.equals(Group, a, b);
  }
}

/**
 * Groups is a list of groups.
 *
 * @generated from message v1.Groups
 */
export class Groups extends Message<Groups> {
  /**
   * Items is the list of groups.
   *
   * @generated from field: repeated v1.Group items = 1;
   */
  items: Group[] = [];

  constructor(data?: PartialMessage<Groups>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Groups";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Group, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Groups {
    return new Groups().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Groups {
    return new Groups().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Groups {
    return new Groups().fromJsonString(jsonString, options);
  }

  static equals(a: Groups | PlainMessage<Groups> | undefined, b: Groups | PlainMessage<Groups> | undefined): boolean {
    return proto3.util.equals(Groups, a, b);
  }
}

/**
 * RBACAction is an action that can be performed on a resource. It is used by implementations
 * to evaluate rules.
 *
 * @generated from message v1.RBACAction
 */
export class RBACAction extends Message<RBACAction> {
  /**
   * Resource is the resource on which the action is performed.
   *
   * @generated from field: v1.RuleResource resource = 1;
   */
  resource = RuleResource.RESOURCE_UNKNOWN;

  /**
   * ResourceName is the name of the resource on which the action is
   * performed.
   *
   * @generated from field: string resourceName = 2;
   */
  resourceName = "";

  /**
   * Verb is the verb that is performed on the resource.
   *
   * @generated from field: v1.RuleVerb verb = 3;
   */
  verb = RuleVerb.VERB_UNKNOWN;

  constructor(data?: PartialMessage<RBACAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.RBACAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "enum", T: proto3.getEnumType(RuleResource) },
    { no: 2, name: "resourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "verb", kind: "enum", T: proto3.getEnumType(RuleVerb) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RBACAction {
    return new RBACAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RBACAction {
    return new RBACAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RBACAction {
    return new RBACAction().fromJsonString(jsonString, options);
  }

  static equals(a: RBACAction | PlainMessage<RBACAction> | undefined, b: RBACAction | PlainMessage<RBACAction> | undefined): boolean {
    return proto3.util.equals(RBACAction, a, b);
  }
}

