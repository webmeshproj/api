//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1
// @generated from file v1/storage_query.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * NetworkState represents the full network state as returned by
 * a network state query.
 *
 * @generated from message v1.NetworkState
 */
export declare class NetworkState extends Message<NetworkState> {
  /**
   * @generated from field: string networkV4 = 1;
   */
  networkV4: string;

  /**
   * @generated from field: string networkV6 = 2;
   */
  networkV6: string;

  /**
   * @generated from field: string domain = 3;
   */
  domain: string;

  constructor(data?: PartialMessage<NetworkState>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.NetworkState";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkState;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkState;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkState;

  static equals(a: NetworkState | PlainMessage<NetworkState> | undefined, b: NetworkState | PlainMessage<NetworkState> | undefined): boolean;
}

/**
 * QueryRequest is sent by the application to the node to query the mesh for
 * information.
 *
 * @generated from message v1.QueryRequest
 */
export declare class QueryRequest extends Message<QueryRequest> {
  /**
   * command is the command of the query.
   *
   * @generated from field: v1.QueryRequest.QueryCommand command = 1;
   */
  command: QueryRequest_QueryCommand;

  /**
   * type is the type of the query.
   *
   * @generated from field: v1.QueryRequest.QueryType type = 2;
   */
  type: QueryRequest_QueryType;

  /**
   * query is the string of the query. This follows the format of a label
   * selector and is only applicable for certain queries. For get queries
   * this will usually be an ID. For list queries this will usually be one
   * or more filters.
   *
   * @generated from field: string query = 3;
   */
  query: string;

  constructor(data?: PartialMessage<QueryRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.QueryRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRequest;

  static equals(a: QueryRequest | PlainMessage<QueryRequest> | undefined, b: QueryRequest | PlainMessage<QueryRequest> | undefined): boolean;
}

/**
 * QueryCommand is the type of the query.
 *
 * @generated from enum v1.QueryRequest.QueryCommand
 */
export declare enum QueryRequest_QueryCommand {
  /**
   * GET is the command to get a value.
   *
   * @generated from enum value: GET = 0;
   */
  GET = 0,

  /**
   * LIST is the command to list keys with an optional prefix.
   *
   * @generated from enum value: LIST = 1;
   */
  LIST = 1,
}

/**
 * QueryType is the type of object being queried.
 *
 * @generated from enum v1.QueryRequest.QueryType
 */
export declare enum QueryRequest_QueryType {
  /**
   * VALUE represents a raw value query at a supplied key.
   *
   * @generated from enum value: VALUE = 0;
   */
  VALUE = 0,

  /**
   * KEYS is the type for querying keys.
   *
   * @generated from enum value: KEYS = 1;
   */
  KEYS = 1,

  /**
   * PEERS is the type for querying peers.
   *
   * @generated from enum value: PEERS = 2;
   */
  PEERS = 2,

  /**
   * EDGES is the type for querying edges.
   *
   * @generated from enum value: EDGES = 3;
   */
  EDGES = 3,

  /**
   * ROUTES is the type for querying routes.
   *
   * @generated from enum value: ROUTES = 4;
   */
  ROUTES = 4,

  /**
   * ACLS is the type for querying ACLs.
   *
   * @generated from enum value: ACLS = 5;
   */
  ACLS = 5,

  /**
   * ROLES is the type for querying roles.
   *
   * @generated from enum value: ROLES = 6;
   */
  ROLES = 6,

  /**
   * ROLEBINDINGS is the type for querying role bindings.
   *
   * @generated from enum value: ROLEBINDINGS = 7;
   */
  ROLEBINDINGS = 7,

  /**
   * GROUPS is the type for querying groups.
   *
   * @generated from enum value: GROUPS = 8;
   */
  GROUPS = 8,

  /**
   * NETWORK_STATE is the type for querying network configuration.
   *
   * @generated from enum value: NETWORK_STATE = 9;
   */
  NETWORK_STATE = 9,

  /**
   * RBAC_STATE is the type for querying RBAC configuration.
   * This will return a single item of true or false.
   *
   * @generated from enum value: RBAC_STATE = 10;
   */
  RBAC_STATE = 10,
}

/**
 * QueryResponse is the message containing a mesh query result.
 *
 * @generated from message v1.QueryResponse
 */
export declare class QueryResponse extends Message<QueryResponse> {
  /**
   * items contain the results of the query. These will be protobuf
   * json-encoded objects of the given query type.
   *
   * @generated from field: repeated bytes items = 1;
   */
  items: Uint8Array[];

  /**
   * error is an error that happened during the query. This will always
   * be populated on errors, but single-flight queries will return
   * a coded error instead.
   *
   * @generated from field: string error = 4;
   */
  error: string;

  constructor(data?: PartialMessage<QueryResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.QueryResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse;

  static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean;
}

/**
 * SubscribeRequest is sent by the application to the node to subscribe to
 * events. This currently only supports database events.
 *
 * @generated from message v1.SubscribeRequest
 */
export declare class SubscribeRequest extends Message<SubscribeRequest> {
  /**
   * prefix is the prefix of the events to subscribe to.
   *
   * @generated from field: bytes prefix = 1;
   */
  prefix: Uint8Array;

  constructor(data?: PartialMessage<SubscribeRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.SubscribeRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribeRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribeRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribeRequest;

  static equals(a: SubscribeRequest | PlainMessage<SubscribeRequest> | undefined, b: SubscribeRequest | PlainMessage<SubscribeRequest> | undefined): boolean;
}

/**
 * SubscriptionEvent is a message containing a subscription event.
 *
 * @generated from message v1.SubscriptionEvent
 */
export declare class SubscriptionEvent extends Message<SubscriptionEvent> {
  /**
   * key is the key of the event.
   *
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * value is the value of the event. This will be the raw value of the key.
   *
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  constructor(data?: PartialMessage<SubscriptionEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.SubscriptionEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscriptionEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscriptionEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscriptionEvent;

  static equals(a: SubscriptionEvent | PlainMessage<SubscriptionEvent> | undefined, b: SubscriptionEvent | PlainMessage<SubscriptionEvent> | undefined): boolean;
}

/**
 * PublishRequest is sent by the application to the node to publish events.
 * This currently only supports database events.
 *
 * @generated from message v1.PublishRequest
 */
export declare class PublishRequest extends Message<PublishRequest> {
  /**
   * key is the key of the event.
   *
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * value is the value of the event. This will be the raw value of the key.
   *
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  /**
   * ttl is the time for the event to live in the database.
   *
   * @generated from field: google.protobuf.Duration ttl = 3;
   */
  ttl?: Duration;

  constructor(data?: PartialMessage<PublishRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.PublishRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishRequest;

  static equals(a: PublishRequest | PlainMessage<PublishRequest> | undefined, b: PublishRequest | PlainMessage<PublishRequest> | undefined): boolean;
}

/**
 * PublishResponse is the response to a publish request. This is currently
 * empty.
 *
 * @generated from message v1.PublishResponse
 */
export declare class PublishResponse extends Message<PublishResponse> {
  constructor(data?: PartialMessage<PublishResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "v1.PublishResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishResponse;

  static equals(a: PublishResponse | PlainMessage<PublishResponse> | undefined, b: PublishResponse | PlainMessage<PublishResponse> | undefined): boolean;
}

