//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file v1/plugin.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct } from "@bufbuild/protobuf";
import { MeshNode } from "./node_pb.js";

/**
 * PluginConfiguration is the message containing the configuration of a plugin.
 *
 * @generated from message v1.PluginConfiguration
 */
export class PluginConfiguration extends Message<PluginConfiguration> {
  /**
   * Config is the configuration for the plugin. This will be specific
   * for each plugin.
   *
   * @generated from field: google.protobuf.Struct config = 1;
   */
  config?: Struct;

  /**
   * NodeConfig is the configuration of the node and the network that it is a part of.
   *
   * @generated from field: v1.NodeConfiguration nodeConfig = 2;
   */
  nodeConfig?: NodeConfiguration;

  constructor(data?: PartialMessage<PluginConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.PluginConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: Struct },
    { no: 2, name: "nodeConfig", kind: "message", T: NodeConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginConfiguration {
    return new PluginConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginConfiguration {
    return new PluginConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginConfiguration {
    return new PluginConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: PluginConfiguration | PlainMessage<PluginConfiguration> | undefined, b: PluginConfiguration | PlainMessage<PluginConfiguration> | undefined): boolean {
    return proto3.util.equals(PluginConfiguration, a, b);
  }
}

/**
 * NodeConfiguration is the message containing the configuration of the
 * node and the network that it is a part of.
 *
 * @generated from message v1.NodeConfiguration
 */
export class NodeConfiguration extends Message<NodeConfiguration> {
  /**
   * ID is the ID of the node.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * NetworkIPv4 is the IPv4 network that the node is a part of.
   *
   * @generated from field: string networkIPv4 = 2;
   */
  networkIPv4 = "";

  /**
   * NetworkIPv6 is the IPv6 network that the node is a part of.
   *
   * @generated from field: string networkIPv6 = 3;
   */
  networkIPv6 = "";

  /**
   * AddressIPv4 is the IPv4 address of the node.
   *
   * @generated from field: string addressIPv4 = 4;
   */
  addressIPv4 = "";

  /**
   * AddressIPv6 is the IPv6 address of the node.
   *
   * @generated from field: string addressIPv6 = 5;
   */
  addressIPv6 = "";

  /**
   * Domain is the domain of the network.
   *
   * @generated from field: string domain = 6;
   */
  domain = "";

  /**
   * PrivateKey is the private key of the node.
   *
   * @generated from field: bytes privateKey = 7;
   */
  privateKey = new Uint8Array(0);

  constructor(data?: PartialMessage<NodeConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.NodeConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "networkIPv4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "networkIPv6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "addressIPv4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "addressIPv6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "privateKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeConfiguration {
    return new NodeConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeConfiguration {
    return new NodeConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeConfiguration {
    return new NodeConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: NodeConfiguration | PlainMessage<NodeConfiguration> | undefined, b: NodeConfiguration | PlainMessage<NodeConfiguration> | undefined): boolean {
    return proto3.util.equals(NodeConfiguration, a, b);
  }
}

/**
 * PluginInfo is the information of a plugin.
 *
 * @generated from message v1.PluginInfo
 */
export class PluginInfo extends Message<PluginInfo> {
  /**
   * Name is the name of the plugin.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Version is the version of the plugin.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Description is the description of the plugin.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Capabilities is the capabilities of the plugin.
   *
   * @generated from field: repeated v1.PluginInfo.PluginCapability capabilities = 5;
   */
  capabilities: PluginInfo_PluginCapability[] = [];

  constructor(data?: PartialMessage<PluginInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.PluginInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "capabilities", kind: "enum", T: proto3.getEnumType(PluginInfo_PluginCapability), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginInfo {
    return new PluginInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginInfo {
    return new PluginInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginInfo {
    return new PluginInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PluginInfo | PlainMessage<PluginInfo> | undefined, b: PluginInfo | PlainMessage<PluginInfo> | undefined): boolean {
    return proto3.util.equals(PluginInfo, a, b);
  }
}

/**
 * PluginCapability is the capabilities of a plugin.
 *
 * @generated from enum v1.PluginInfo.PluginCapability
 */
export enum PluginInfo_PluginCapability {
  /**
   * UNKNOWN is the default value of PluginCapability.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * STORAGE_PROVIDER indicates that the plugin can provide storage and underlying consistency.
   *
   * @generated from enum value: STORAGE_PROVIDER = 1;
   */
  STORAGE_PROVIDER = 1,

  /**
   * AUTH indicates that the plugin is an auth plugin.
   *
   * @generated from enum value: AUTH = 2;
   */
  AUTH = 2,

  /**
   * WATCH indicates that the plugin wants to receive watch events.
   *
   * @generated from enum value: WATCH = 3;
   */
  WATCH = 3,

  /**
   * IPAMV4 indicates that the plugin is an IPv4 IPAM plugin.
   *
   * @generated from enum value: IPAMV4 = 4;
   */
  IPAMV4 = 4,

  /**
   * STORAGE_QUERIER indicates a plugin that wants to interact with storage.
   *
   * @generated from enum value: STORAGE_QUERIER = 5;
   */
  STORAGE_QUERIER = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(PluginInfo_PluginCapability)
proto3.util.setEnumType(PluginInfo_PluginCapability, "v1.PluginInfo.PluginCapability", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "STORAGE_PROVIDER" },
  { no: 2, name: "AUTH" },
  { no: 3, name: "WATCH" },
  { no: 4, name: "IPAMV4" },
  { no: 5, name: "STORAGE_QUERIER" },
]);

/**
 * AuthenticationRequest is the message containing an authentication request.
 *
 * @generated from message v1.AuthenticationRequest
 */
export class AuthenticationRequest extends Message<AuthenticationRequest> {
  /**
   * Headers are the headers of the request.
   *
   * @generated from field: map<string, string> headers = 1;
   */
  headers: { [key: string]: string } = {};

  /**
   * Certificates are the DER encoded certificates of the request.
   *
   * @generated from field: repeated bytes certificates = 2;
   */
  certificates: Uint8Array[] = [];

  constructor(data?: PartialMessage<AuthenticationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AuthenticationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "headers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "certificates", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticationRequest {
    return new AuthenticationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticationRequest {
    return new AuthenticationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticationRequest {
    return new AuthenticationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticationRequest | PlainMessage<AuthenticationRequest> | undefined, b: AuthenticationRequest | PlainMessage<AuthenticationRequest> | undefined): boolean {
    return proto3.util.equals(AuthenticationRequest, a, b);
  }
}

/**
 * AuthenticationResponse is the message containing an authentication response.
 *
 * @generated from message v1.AuthenticationResponse
 */
export class AuthenticationResponse extends Message<AuthenticationResponse> {
  /**
   * ID is the id of the authenticated user.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<AuthenticationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AuthenticationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticationResponse {
    return new AuthenticationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticationResponse {
    return new AuthenticationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticationResponse {
    return new AuthenticationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticationResponse | PlainMessage<AuthenticationResponse> | undefined, b: AuthenticationResponse | PlainMessage<AuthenticationResponse> | undefined): boolean {
    return proto3.util.equals(AuthenticationResponse, a, b);
  }
}

/**
 * Event is the message containing a watch event.
 *
 * @generated from message v1.Event
 */
export class Event extends Message<Event> {
  /**
   * Type is the type of the watch event.
   *
   * @generated from field: v1.Event.WatchEvent type = 1;
   */
  type = Event_WatchEvent.UNKNOWN;

  /**
   * Event is the data of the watch event.
   *
   * @generated from oneof v1.Event.event
   */
  event: {
    /**
     * Node is the node that the event is about.
     *
     * @generated from field: v1.MeshNode node = 2;
     */
    value: MeshNode;
    case: "node";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Event>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Event";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(Event_WatchEvent) },
    { no: 2, name: "node", kind: "message", T: MeshNode, oneof: "event" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event {
    return new Event().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJsonString(jsonString, options);
  }

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean {
    return proto3.util.equals(Event, a, b);
  }
}

/**
 * WatchEvent is the type of a watch event.
 *
 * @generated from enum v1.Event.WatchEvent
 */
export enum Event_WatchEvent {
  /**
   * UNKNOWN is the default value of WatchEvent.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * NODE_JOIN indicates that a node has joined the cluster.
   *
   * @generated from enum value: NODE_JOIN = 1;
   */
  NODE_JOIN = 1,

  /**
   * NODE_LEAVE indicates that a node has left the cluster.
   *
   * @generated from enum value: NODE_LEAVE = 2;
   */
  NODE_LEAVE = 2,

  /**
   * LEADER_CHANGE indicates that the leader of the cluster has changed.
   *
   * @generated from enum value: LEADER_CHANGE = 3;
   */
  LEADER_CHANGE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Event_WatchEvent)
proto3.util.setEnumType(Event_WatchEvent, "v1.Event.WatchEvent", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "NODE_JOIN" },
  { no: 2, name: "NODE_LEAVE" },
  { no: 3, name: "LEADER_CHANGE" },
]);

/**
 * AllocateIPRequest is the message containing an IP allocation request.
 *
 * @generated from message v1.AllocateIPRequest
 */
export class AllocateIPRequest extends Message<AllocateIPRequest> {
  /**
   * NodeID is the node that the IP should be allocated for.
   *
   * @generated from field: string nodeID = 1;
   */
  nodeID = "";

  /**
   * Subnet is the subnet that the IP should be allocated from.
   *
   * @generated from field: string subnet = 2;
   */
  subnet = "";

  constructor(data?: PartialMessage<AllocateIPRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AllocateIPRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subnet", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocateIPRequest {
    return new AllocateIPRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocateIPRequest {
    return new AllocateIPRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocateIPRequest {
    return new AllocateIPRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AllocateIPRequest | PlainMessage<AllocateIPRequest> | undefined, b: AllocateIPRequest | PlainMessage<AllocateIPRequest> | undefined): boolean {
    return proto3.util.equals(AllocateIPRequest, a, b);
  }
}

/**
 * AllocatedIP is the message containing an allocated IP.
 *
 * @generated from message v1.AllocatedIP
 */
export class AllocatedIP extends Message<AllocatedIP> {
  /**
   * IP is the allocated IP. It should be returned in CIDR notation.
   *
   * @generated from field: string ip = 1;
   */
  ip = "";

  constructor(data?: PartialMessage<AllocatedIP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AllocatedIP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedIP {
    return new AllocatedIP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedIP {
    return new AllocatedIP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedIP {
    return new AllocatedIP().fromJsonString(jsonString, options);
  }

  static equals(a: AllocatedIP | PlainMessage<AllocatedIP> | undefined, b: AllocatedIP | PlainMessage<AllocatedIP> | undefined): boolean {
    return proto3.util.equals(AllocatedIP, a, b);
  }
}

/**
 * ReleaseIPRequest is the message containing an IP release request.
 *
 * @generated from message v1.ReleaseIPRequest
 */
export class ReleaseIPRequest extends Message<ReleaseIPRequest> {
  /**
   * NodeID is the node that the IP should be released for.
   *
   * @generated from field: string nodeID = 1;
   */
  nodeID = "";

  /**
   * IP is the IP that should be released.
   *
   * @generated from field: string ip = 2;
   */
  ip = "";

  constructor(data?: PartialMessage<ReleaseIPRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ReleaseIPRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseIPRequest {
    return new ReleaseIPRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseIPRequest {
    return new ReleaseIPRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseIPRequest {
    return new ReleaseIPRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReleaseIPRequest | PlainMessage<ReleaseIPRequest> | undefined, b: ReleaseIPRequest | PlainMessage<ReleaseIPRequest> | undefined): boolean {
    return proto3.util.equals(ReleaseIPRequest, a, b);
  }
}

