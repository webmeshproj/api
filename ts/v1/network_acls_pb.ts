//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file v1/network_acls.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * ACLAction is the action to take when a request matches an ACL.
 *
 * @generated from enum v1.ACLAction
 */
export enum ACLAction {
  /**
   * ACTION_UNKNOWN is the default action for ACLs. It is synonymous with ACTION_DENY.
   *
   * @generated from enum value: ACTION_UNKNOWN = 0;
   */
  ACTION_UNKNOWN = 0,

  /**
   * ACTION_ACCEPT allows the request to proceed.
   *
   * @generated from enum value: ACTION_ACCEPT = 1;
   */
  ACTION_ACCEPT = 1,

  /**
   * ACTION_DENY denies the request.
   *
   * @generated from enum value: ACTION_DENY = 2;
   */
  ACTION_DENY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ACLAction)
proto3.util.setEnumType(ACLAction, "v1.ACLAction", [
  { no: 0, name: "ACTION_UNKNOWN" },
  { no: 1, name: "ACTION_ACCEPT" },
  { no: 2, name: "ACTION_DENY" },
]);

/**
 * NetworkACL is a network ACL.
 *
 * @generated from message v1.NetworkACL
 */
export class NetworkACL extends Message<NetworkACL> {
  /**
   * Name is the name of the ACL.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Priority is the priority of the ACL. ACLs with higher priority are evaluated first.
   *
   * @generated from field: int32 priority = 2;
   */
  priority = 0;

  /**
   * Action is the action to take when a request matches the ACL.
   *
   * @generated from field: v1.ACLAction action = 3;
   */
  action = ACLAction.ACTION_UNKNOWN;

  /**
   * SourceNodes is a list of source nodes to match against. If empty, all nodes are matched. Groups
   * can be specified with the prefix "group:". If one or more of the nodes is '*', all nodes are matched.
   *
   * @generated from field: repeated string sourceNodes = 4;
   */
  sourceNodes: string[] = [];

  /**
   * DestinationNodes is a list of destination nodes to match against. If empty, all nodes are matched.
   * Groups can be specified with the prefix "group:". If one or more of the nodes is '*', all nodes are matched.
   *
   * @generated from field: repeated string destinationNodes = 5;
   */
  destinationNodes: string[] = [];

  /**
   * SourceCIDRs is a list of source CIDRs to match against. If empty, all CIDRs are matched.
   * If one or more of the CIDRs is '*', all CIDRs are matched.
   *
   * @generated from field: repeated string sourceCIDRs = 6;
   */
  sourceCIDRs: string[] = [];

  /**
   * DestinationCIDRs is a list of destination CIDRs to match against. If empty, all CIDRs are matched.
   * If one or more of the CIDRs is '*', all CIDRs are matched.
   *
   * @generated from field: repeated string destinationCIDRs = 7;
   */
  destinationCIDRs: string[] = [];

  constructor(data?: PartialMessage<NetworkACL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.NetworkACL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "priority", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "action", kind: "enum", T: proto3.getEnumType(ACLAction) },
    { no: 4, name: "sourceNodes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "destinationNodes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "sourceCIDRs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "destinationCIDRs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkACL {
    return new NetworkACL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkACL {
    return new NetworkACL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkACL {
    return new NetworkACL().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkACL | PlainMessage<NetworkACL> | undefined, b: NetworkACL | PlainMessage<NetworkACL> | undefined): boolean {
    return proto3.util.equals(NetworkACL, a, b);
  }
}

/**
 * NetworkACLs is a list of network ACLs.
 *
 * @generated from message v1.NetworkACLs
 */
export class NetworkACLs extends Message<NetworkACLs> {
  /**
   * Items is the list of network ACLs.
   *
   * @generated from field: repeated v1.NetworkACL items = 1;
   */
  items: NetworkACL[] = [];

  constructor(data?: PartialMessage<NetworkACLs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.NetworkACLs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: NetworkACL, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkACLs {
    return new NetworkACLs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkACLs {
    return new NetworkACLs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkACLs {
    return new NetworkACLs().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkACLs | PlainMessage<NetworkACLs> | undefined, b: NetworkACLs | PlainMessage<NetworkACLs> | undefined): boolean {
    return proto3.util.equals(NetworkACLs, a, b);
  }
}

/**
 * Route is a route that is broadcasted by one or more nodes.
 *
 * @generated from message v1.Route
 */
export class Route extends Message<Route> {
  /**
   * Name is the name of the route.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Node is the node that broadcasts the route. A group can be specified with the prefix "group:".
   *
   * @generated from field: string node = 2;
   */
  node = "";

  /**
   * DestinationCIDRs are the destination CIDRs of the route.
   *
   * @generated from field: repeated string destinationCIDRs = 3;
   */
  destinationCIDRs: string[] = [];

  /**
   * NextHopNode is an optional node that is used as the next hop for the route.
   * This field is not currentl used.
   *
   * @generated from field: string nextHopNode = 4;
   */
  nextHopNode = "";

  constructor(data?: PartialMessage<Route>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Route";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "node", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "destinationCIDRs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "nextHopNode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Route {
    return new Route().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Route {
    return new Route().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Route {
    return new Route().fromJsonString(jsonString, options);
  }

  static equals(a: Route | PlainMessage<Route> | undefined, b: Route | PlainMessage<Route> | undefined): boolean {
    return proto3.util.equals(Route, a, b);
  }
}

/**
 * Routes is a list of routes.
 *
 * @generated from message v1.Routes
 */
export class Routes extends Message<Routes> {
  /**
   * Items is the list of routes.
   *
   * @generated from field: repeated v1.Route items = 1;
   */
  items: Route[] = [];

  constructor(data?: PartialMessage<Routes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Routes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Route, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Routes {
    return new Routes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Routes {
    return new Routes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Routes {
    return new Routes().fromJsonString(jsonString, options);
  }

  static equals(a: Routes | PlainMessage<Routes> | undefined, b: Routes | PlainMessage<Routes> | undefined): boolean {
    return proto3.util.equals(Routes, a, b);
  }
}

/**
 * NetworkAction is an action that can be performed on a network resource. It is used
 * by implementations to evaluate network ACLs.
 *
 * @generated from message v1.NetworkAction
 */
export class NetworkAction extends Message<NetworkAction> {
  /**
   * SrcNode is the source node of the action.
   *
   * @generated from field: string srcNode = 1;
   */
  srcNode = "";

  /**
   * SrcCIDR is the source CIDR of the action.
   *
   * @generated from field: string srcCIDR = 2;
   */
  srcCIDR = "";

  /**
   * DstNode is the destination node of the action.
   *
   * @generated from field: string dstNode = 3;
   */
  dstNode = "";

  /**
   * DstCIDR is the destination CIDR of the action.
   *
   * @generated from field: string dstCIDR = 4;
   */
  dstCIDR = "";

  constructor(data?: PartialMessage<NetworkAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.NetworkAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "srcNode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "srcCIDR", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dstNode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "dstCIDR", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkAction {
    return new NetworkAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkAction {
    return new NetworkAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkAction {
    return new NetworkAction().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkAction | PlainMessage<NetworkAction> | undefined, b: NetworkAction | PlainMessage<NetworkAction> | undefined): boolean {
    return proto3.util.equals(NetworkAction, a, b);
  }
}

