//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file v1/app.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct, Timestamp } from "@bufbuild/protobuf";
import { Feature, InterfaceMetrics, MeshNode } from "./node_pb.js";
import { QueryRequest } from "./storage_query_pb.js";

/**
 * NetworkAuthMethod are types of RPC credentials to supply to mesh nodes.
 *
 * @generated from enum v1.NetworkAuthMethod
 */
export enum NetworkAuthMethod {
  /**
   * NO_AUTH is used to indicate that no authentication is required.
   *
   * @generated from enum value: NO_AUTH = 0;
   */
  NO_AUTH = 0,

  /**
   * BASIC is used to indicate that basic authentication is required.
   *
   * @generated from enum value: BASIC = 1;
   */
  BASIC = 1,

  /**
   * LDAP is used to indicate that LDAP authentication is required.
   *
   * @generated from enum value: LDAP = 2;
   */
  LDAP = 2,

  /**
   * ID is used to indicate that an identity is required.
   *
   * @generated from enum value: ID = 3;
   */
  ID = 3,

  /**
   * MTLS is used to indicate that mutual TLS authentication is required.
   * The TLS object should be used to configure the TLS connection.
   *
   * @generated from enum value: MTLS = 4;
   */
  MTLS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(NetworkAuthMethod)
proto3.util.setEnumType(NetworkAuthMethod, "v1.NetworkAuthMethod", [
  { no: 0, name: "NO_AUTH" },
  { no: 1, name: "BASIC" },
  { no: 2, name: "LDAP" },
  { no: 3, name: "ID" },
  { no: 4, name: "MTLS" },
]);

/**
 * DaemonConnStatus are the statuses of a mesh connection.
 *
 * @generated from enum v1.DaemonConnStatus
 */
export enum DaemonConnStatus {
  /**
   * DISCONNECTED indicates that the node is not connected to a mesh.
   *
   * @generated from enum value: DISCONNECTED = 0;
   */
  DISCONNECTED = 0,

  /**
   * CONNECTING indicates that the node is in the process of connecting to a mesh.
   *
   * @generated from enum value: CONNECTING = 1;
   */
  CONNECTING = 1,

  /**
   * CONNECTED indicates that the node is connected to a mesh.
   *
   * @generated from enum value: CONNECTED = 2;
   */
  CONNECTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DaemonConnStatus)
proto3.util.setEnumType(DaemonConnStatus, "v1.DaemonConnStatus", [
  { no: 0, name: "DISCONNECTED" },
  { no: 1, name: "CONNECTING" },
  { no: 2, name: "CONNECTED" },
]);

/**
 * PutConnectionRequest is sent by an application to a daemon to store the parameters
 * for a mesh connection.
 *
 * @generated from message v1.PutConnectionRequest
 */
export class PutConnectionRequest extends Message<PutConnectionRequest> {
  /**
   * ID is the unique identifier of the connection. If not provided
   * one will be generated.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Parameters are the parameters for the connection.
   *
   * @generated from field: v1.ConnectionParameters parameters = 2;
   */
  parameters?: ConnectionParameters;

  /**
   * Metadata are arbitrary key/value pairs to store with the connection.
   *
   * @generated from field: google.protobuf.Struct metadata = 3;
   */
  metadata?: Struct;

  constructor(data?: PartialMessage<PutConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.PutConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "parameters", kind: "message", T: ConnectionParameters },
    { no: 3, name: "metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutConnectionRequest {
    return new PutConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutConnectionRequest {
    return new PutConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutConnectionRequest {
    return new PutConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PutConnectionRequest | PlainMessage<PutConnectionRequest> | undefined, b: PutConnectionRequest | PlainMessage<PutConnectionRequest> | undefined): boolean {
    return proto3.util.equals(PutConnectionRequest, a, b);
  }
}

/**
 * PutConnectionResponse is returned by the PutConnection RPC.
 *
 * @generated from message v1.PutConnectionResponse
 */
export class PutConnectionResponse extends Message<PutConnectionResponse> {
  /**
   * ID is the unique identifier of the connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<PutConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.PutConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutConnectionResponse {
    return new PutConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutConnectionResponse {
    return new PutConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutConnectionResponse {
    return new PutConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PutConnectionResponse | PlainMessage<PutConnectionResponse> | undefined, b: PutConnectionResponse | PlainMessage<PutConnectionResponse> | undefined): boolean {
    return proto3.util.equals(PutConnectionResponse, a, b);
  }
}

/**
 * GetConnectionRequest is sent by an application to a daemon to retrieve the parameters
 * and current status of a mesh connection.
 *
 * @generated from message v1.GetConnectionRequest
 */
export class GetConnectionRequest extends Message<GetConnectionRequest> {
  /**
   * ID is the unique identifier of the connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.GetConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionRequest {
    return new GetConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionRequest {
    return new GetConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionRequest {
    return new GetConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionRequest | PlainMessage<GetConnectionRequest> | undefined, b: GetConnectionRequest | PlainMessage<GetConnectionRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionRequest, a, b);
  }
}

/**
 * GetConnectionResponse is returned by the GetConnection RPC.
 *
 * @generated from message v1.GetConnectionResponse
 */
export class GetConnectionResponse extends Message<GetConnectionResponse> {
  /**
   * Status is the status of the connection.
   *
   * @generated from field: v1.DaemonConnStatus status = 1;
   */
  status = DaemonConnStatus.DISCONNECTED;

  /**
   * Parameters are the parameters for the connection.
   *
   * @generated from field: v1.ConnectionParameters parameters = 2;
   */
  parameters?: ConnectionParameters;

  /**
   * Metadata are arbitrary key/value pairs stored with the connection.
   *
   * @generated from field: google.protobuf.Struct metadata = 3;
   */
  metadata?: Struct;

  /**
   * Node is the node information for the connection.
   * This is only populated when the connection is connected.
   *
   * @generated from field: v1.MeshNode node = 4;
   */
  node?: MeshNode;

  /**
   * IPv4Network is the IPv4 network of the mesh. 
   * This is only populated when the connection is connected.
   *
   * @generated from field: string ipv4Network = 5;
   */
  ipv4Network = "";

  /**
   * IPv6Network is the IPv6 network of the mesh.
   * This is only populated when the connection is connected.
   *
   * @generated from field: string ipv6Network = 6;
   */
  ipv6Network = "";

  /**
   * Domain is the domain of the mesh.
   * This is only populated when the connection is connected.
   *
   * @generated from field: string domain = 7;
   */
  domain = "";

  constructor(data?: PartialMessage<GetConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.GetConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(DaemonConnStatus) },
    { no: 2, name: "parameters", kind: "message", T: ConnectionParameters },
    { no: 3, name: "metadata", kind: "message", T: Struct },
    { no: 4, name: "node", kind: "message", T: MeshNode },
    { no: 5, name: "ipv4Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ipv6Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionResponse {
    return new GetConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionResponse {
    return new GetConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionResponse {
    return new GetConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionResponse | PlainMessage<GetConnectionResponse> | undefined, b: GetConnectionResponse | PlainMessage<GetConnectionResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionResponse, a, b);
  }
}

/**
 * ListConnectionsRequest is sent by an application to a daemon to retrieve the parameters
 * and current status of all mesh connections.
 *
 * @generated from message v1.ListConnectionsRequest
 */
export class ListConnectionsRequest extends Message<ListConnectionsRequest> {
  /**
   * IDs are the unique identifiers of the connections to retrieve information for.
   * If not provided, metrics for all known connections will be returned.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<ListConnectionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ListConnectionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListConnectionsRequest {
    return new ListConnectionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListConnectionsRequest {
    return new ListConnectionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListConnectionsRequest {
    return new ListConnectionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListConnectionsRequest | PlainMessage<ListConnectionsRequest> | undefined, b: ListConnectionsRequest | PlainMessage<ListConnectionsRequest> | undefined): boolean {
    return proto3.util.equals(ListConnectionsRequest, a, b);
  }
}

/**
 * ListConnectionsResponse is returned by the ListConnections RPC.
 *
 * @generated from message v1.ListConnectionsResponse
 */
export class ListConnectionsResponse extends Message<ListConnectionsResponse> {
  /**
   * Connections are the parameters and statuses of all connections.
   *
   * @generated from field: map<string, v1.GetConnectionResponse> connections = 1;
   */
  connections: { [key: string]: GetConnectionResponse } = {};

  constructor(data?: PartialMessage<ListConnectionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ListConnectionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connections", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GetConnectionResponse} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListConnectionsResponse {
    return new ListConnectionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListConnectionsResponse {
    return new ListConnectionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListConnectionsResponse {
    return new ListConnectionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListConnectionsResponse | PlainMessage<ListConnectionsResponse> | undefined, b: ListConnectionsResponse | PlainMessage<ListConnectionsResponse> | undefined): boolean {
    return proto3.util.equals(ListConnectionsResponse, a, b);
  }
}

/**
 * ConnectionParameters are the parameters for a mesh connection.
 *
 * @generated from message v1.ConnectionParameters
 */
export class ConnectionParameters extends Message<ConnectionParameters> {
  /**
   * AuthMethod is the type of authentication to use.
   *
   * @generated from field: v1.NetworkAuthMethod authMethod = 2;
   */
  authMethod = NetworkAuthMethod.NO_AUTH;

  /**
   * AuthCredentials are additional credentials as required by the authType. 
   *
   * @generated from field: map<string, string> authCredentials = 3;
   */
  authCredentials: { [key: string]: string } = {};

  /**
   * AddrType is the type of join addresses in the addrs list.
   *
   * @generated from field: v1.ConnectionParameters.AddrType addrType = 4;
   */
  addrType = ConnectionParameters_AddrType.ADDR;

  /**
   * Addrs are the join addresses to use to connect to the mesh.
   *
   * @generated from field: repeated string addrs = 5;
   */
  addrs: string[] = [];

  /**
   * Networking is the networking configuration to use.
   *
   * @generated from field: v1.MeshConnNetworking networking = 6;
   */
  networking?: MeshConnNetworking;

  /**
   * Services are the services to expose to other nodes on the mesh.
   *
   * @generated from field: v1.MeshConnServices services = 7;
   */
  services?: MeshConnServices;

  /**
   * Bootstrap are options for bootstrapping a new mesh.
   *
   * @generated from field: v1.MeshConnBootstrap bootstrap = 8;
   */
  bootstrap?: MeshConnBootstrap;

  /**
   * TLS are TLS configurations for the mesh connection.
   *
   * @generated from field: v1.MeshConnTLS tls = 9;
   */
  tls?: MeshConnTLS;

  constructor(data?: PartialMessage<ConnectionParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ConnectionParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "authMethod", kind: "enum", T: proto3.getEnumType(NetworkAuthMethod) },
    { no: 3, name: "authCredentials", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "addrType", kind: "enum", T: proto3.getEnumType(ConnectionParameters_AddrType) },
    { no: 5, name: "addrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "networking", kind: "message", T: MeshConnNetworking },
    { no: 7, name: "services", kind: "message", T: MeshConnServices },
    { no: 8, name: "bootstrap", kind: "message", T: MeshConnBootstrap },
    { no: 9, name: "tls", kind: "message", T: MeshConnTLS },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionParameters {
    return new ConnectionParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionParameters {
    return new ConnectionParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionParameters {
    return new ConnectionParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionParameters | PlainMessage<ConnectionParameters> | undefined, b: ConnectionParameters | PlainMessage<ConnectionParameters> | undefined): boolean {
    return proto3.util.equals(ConnectionParameters, a, b);
  }
}

/**
 * AddrType is the type of join addresses included in the request.
 *
 * @generated from enum v1.ConnectionParameters.AddrType
 */
export enum ConnectionParameters_AddrType {
  /**
   * ADDR is used to join a mesh using an IP or DNS address.
   *
   * @generated from enum value: ADDR = 0;
   */
  ADDR = 0,

  /**
   * MULTIADDR is used to join a mesh using a multiaddr.
   *
   * @generated from enum value: MULTIADDR = 1;
   */
  MULTIADDR = 1,

  /**
   * RENDEZVOUS is used to join a mesh using a rendezvous string.
   *
   * @generated from enum value: RENDEZVOUS = 2;
   */
  RENDEZVOUS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionParameters_AddrType)
proto3.util.setEnumType(ConnectionParameters_AddrType, "v1.ConnectionParameters.AddrType", [
  { no: 0, name: "ADDR" },
  { no: 1, name: "MULTIADDR" },
  { no: 2, name: "RENDEZVOUS" },
]);

/**
 * AuthHeader is an enumeration of headers that coorespond to the AuthMethod.
 * They are used to pass authentication credentials to the daemon. Enums 
 * cannot be used as map keys, so their string values are used instead.
 *
 * @generated from enum v1.ConnectionParameters.AuthHeader
 */
export enum ConnectionParameters_AuthHeader {
  /**
   * BASIC_USERNAME is the username for basic authentication.
   *
   * @generated from enum value: BASIC_USERNAME = 0;
   */
  BASIC_USERNAME = 0,

  /**
   * BASIC_PASSWORD is the password for basic authentication.
   *
   * @generated from enum value: BASIC_PASSWORD = 1;
   */
  BASIC_PASSWORD = 1,

  /**
   * LDAP_USERNAME is the username for LDAP authentication.
   *
   * @generated from enum value: LDAP_USERNAME = 2;
   */
  LDAP_USERNAME = 2,

  /**
   * LDAP_PASSWORD is the password for LDAP authentication.
   *
   * @generated from enum value: LDAP_PASSWORD = 3;
   */
  LDAP_PASSWORD = 3,

  /**
   * ADDRS_ENVELOPE is the header for a signed envelope containing
   * the join addresses to use to connect to the mesh.
   *
   * @generated from enum value: ADDRS_ENVELOPE = 4;
   */
  ADDRS_ENVELOPE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionParameters_AuthHeader)
proto3.util.setEnumType(ConnectionParameters_AuthHeader, "v1.ConnectionParameters.AuthHeader", [
  { no: 0, name: "BASIC_USERNAME" },
  { no: 1, name: "BASIC_PASSWORD" },
  { no: 2, name: "LDAP_USERNAME" },
  { no: 3, name: "LDAP_PASSWORD" },
  { no: 4, name: "ADDRS_ENVELOPE" },
]);

/**
 * MeshConnNetworking are configurations for networking on a mesh.
 *
 * @generated from message v1.MeshConnNetworking
 */
export class MeshConnNetworking extends Message<MeshConnNetworking> {
  /**
   * UseDNS indicates whether or not to use the DNS servers of the mesh.
   *
   * @generated from field: bool useDNS = 1;
   */
  useDNS = false;

  /**
   * Endpoints are wireguard endpoints to broadcast to the mesh.
   *
   * @generated from field: repeated string endpoints = 2;
   */
  endpoints: string[] = [];

  /**
   * DetectEndpoints enables endpoint detection.
   *
   * @generated from field: bool detectEndpoints = 3;
   */
  detectEndpoints = false;

  /**
   * DetectPrivateEndpoints enables endpoint detection for private addresses.
   * This only makes sense when DetectEndpoints is enabled.
   *
   * @generated from field: bool detectPrivateEndpoints = 4;
   */
  detectPrivateEndpoints = false;

  constructor(data?: PartialMessage<MeshConnNetworking>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnNetworking";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useDNS", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "detectEndpoints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "detectPrivateEndpoints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnNetworking {
    return new MeshConnNetworking().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnNetworking {
    return new MeshConnNetworking().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnNetworking {
    return new MeshConnNetworking().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnNetworking | PlainMessage<MeshConnNetworking> | undefined, b: MeshConnNetworking | PlainMessage<MeshConnNetworking> | undefined): boolean {
    return proto3.util.equals(MeshConnNetworking, a, b);
  }
}

/**
 * MeshConnServices are configurations for exposing services to other nodes on a mesh.
 *
 * @generated from message v1.MeshConnServices
 */
export class MeshConnServices extends Message<MeshConnServices> {
  /**
   * Enabled indicates whether or not to expose services to other nodes.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * EnableLibP2P indicates whether or not to serve the API over libp2p.
   *
   * @generated from field: bool enableLibP2P = 2;
   */
  enableLibP2P = false;

  /**
   * EnableTLS indicates whether or not to use TLS for the API.
   *
   * @generated from field: bool enableTLS = 3;
   */
  enableTLS = false;

  /**
   * Rendezvous is an optional rendezvous string to use for anouncing the service
   * on the IPFS DHT.
   *
   * @generated from field: string rendezvous = 4;
   */
  rendezvous = "";

  /**
   * ListenAddress is a raw IP address and port to listen on.
   *
   * @generated from field: string listenAddress = 5;
   */
  listenAddress = "";

  /**
   * ListenMultiaddrs are multiaddrs to listen on. If not provided and
   * EnableLibP2P is set, the default listen addresses will be used.
   *
   * @generated from field: repeated string listenMultiaddrs = 6;
   */
  listenMultiaddrs: string[] = [];

  /**
   * AuthMetod is the of authentication to enable for the services.
   * Only mTLS and ID are supported.
   *
   * @generated from field: v1.NetworkAuthMethod authMethod = 7;
   */
  authMethod = NetworkAuthMethod.NO_AUTH;

  /**
   * Features are which features to enable on the API.
   *
   * @generated from field: repeated v1.Feature features = 8;
   */
  features: Feature[] = [];

  /**
   * DNS are configurations for running a MeshDNS server.
   *
   * @generated from field: v1.MeshDNSService dns = 9;
   */
  dns?: MeshDNSService;

  constructor(data?: PartialMessage<MeshConnServices>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnServices";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "enableLibP2P", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "enableTLS", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "rendezvous", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "listenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "listenMultiaddrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "authMethod", kind: "enum", T: proto3.getEnumType(NetworkAuthMethod) },
    { no: 8, name: "features", kind: "enum", T: proto3.getEnumType(Feature), repeated: true },
    { no: 9, name: "dns", kind: "message", T: MeshDNSService },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnServices {
    return new MeshConnServices().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnServices {
    return new MeshConnServices().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnServices {
    return new MeshConnServices().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnServices | PlainMessage<MeshConnServices> | undefined, b: MeshConnServices | PlainMessage<MeshConnServices> | undefined): boolean {
    return proto3.util.equals(MeshConnServices, a, b);
  }
}

/**
 * MeshDNSService are configurations for running a MeshDNS server.
 *
 * @generated from message v1.MeshDNSService
 */
export class MeshDNSService extends Message<MeshDNSService> {
  /**
   * Enabled indicates whether or not to run a MeshDNS server.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * ListenUDP is a raw IP address and port to listen on for UDP.
   * Defaults to :53. Set to an empty string to disable.
   *
   * @generated from field: string listenUDP = 2;
   */
  listenUDP = "";

  /**
   * ListenTCP is a raw IP address and port to listen on for TCP.
   * Defaults to :53. Set to an empty string to disable.
   *
   * @generated from field: string listenTCP = 3;
   */
  listenTCP = "";

  constructor(data?: PartialMessage<MeshDNSService>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshDNSService";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "listenUDP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "listenTCP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshDNSService {
    return new MeshDNSService().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshDNSService {
    return new MeshDNSService().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshDNSService {
    return new MeshDNSService().fromJsonString(jsonString, options);
  }

  static equals(a: MeshDNSService | PlainMessage<MeshDNSService> | undefined, b: MeshDNSService | PlainMessage<MeshDNSService> | undefined): boolean {
    return proto3.util.equals(MeshDNSService, a, b);
  }
}

/**
 * MeshConnBootstrap are configurations for bootstrapping a new mesh.
 *
 * @generated from message v1.MeshConnBootstrap
 */
export class MeshConnBootstrap extends Message<MeshConnBootstrap> {
  /**
   * Enabled indicates whether or not to bootstrap a new mesh.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Domain is the domain of the mesh. Defaults to "webmesh.internal".
   *
   * @generated from field: string domain = 2;
   */
  domain = "";

  /**
   * IPv4Network is the IPv4 network of the mesh. Defaults to 172.16.0.0/12.
   *
   * @generated from field: string ipv4Network = 3;
   */
  ipv4Network = "";

  /**
   * RBACEnabled indicates whether or not to enable RBAC on the mesh.
   *
   * @generated from field: bool rbacEnabled = 4;
   */
  rbacEnabled = false;

  /**
   * DefaultNetworkACL is the default network ACL to use for the mesh.
   *
   * @generated from field: v1.MeshConnBootstrap.DefaultNetworkACL defaultNetworkACL = 5;
   */
  defaultNetworkACL = MeshConnBootstrap_DefaultNetworkACL.ACCEPT;

  constructor(data?: PartialMessage<MeshConnBootstrap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnBootstrap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ipv4Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "rbacEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "defaultNetworkACL", kind: "enum", T: proto3.getEnumType(MeshConnBootstrap_DefaultNetworkACL) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnBootstrap {
    return new MeshConnBootstrap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnBootstrap {
    return new MeshConnBootstrap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnBootstrap {
    return new MeshConnBootstrap().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnBootstrap | PlainMessage<MeshConnBootstrap> | undefined, b: MeshConnBootstrap | PlainMessage<MeshConnBootstrap> | undefined): boolean {
    return proto3.util.equals(MeshConnBootstrap, a, b);
  }
}

/**
 * @generated from enum v1.MeshConnBootstrap.DefaultNetworkACL
 */
export enum MeshConnBootstrap_DefaultNetworkACL {
  /**
   * @generated from enum value: ACCEPT = 0;
   */
  ACCEPT = 0,

  /**
   * @generated from enum value: DROP = 1;
   */
  DROP = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(MeshConnBootstrap_DefaultNetworkACL)
proto3.util.setEnumType(MeshConnBootstrap_DefaultNetworkACL, "v1.MeshConnBootstrap.DefaultNetworkACL", [
  { no: 0, name: "ACCEPT" },
  { no: 1, name: "DROP" },
]);

/**
 * MeshhConnTLS are TLS configurations for a mesh connection.
 *
 * @generated from message v1.MeshConnTLS
 */
export class MeshConnTLS extends Message<MeshConnTLS> {
  /**
   * Enabled indicates whether or not to use TLS.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * CACert is a base64 and PEM encoded CA certificate to use for TLS.
   *
   * @generated from field: string caCertData = 2;
   */
  caCertData = "";

  /**
   * CertData is a base64 and PEM encoded certificate to use for TLS.
   *
   * @generated from field: string certData = 3;
   */
  certData = "";

  /**
   * KeyData is a base64 and PEM encoded private key to use for TLS.
   *
   * @generated from field: string keyData = 4;
   */
  keyData = "";

  /**
   * VerifyChainOnly indicates whether or not to only verify the
   * certificate chain.
   *
   * @generated from field: bool verifyChainOnly = 5;
   */
  verifyChainOnly = false;

  /**
   * SkipVerify indicates whether or not to skip verification of the
   * server certificate.
   *
   * @generated from field: bool skipVerify = 6;
   */
  skipVerify = false;

  constructor(data?: PartialMessage<MeshConnTLS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnTLS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "caCertData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "certData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "keyData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "verifyChainOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "skipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnTLS {
    return new MeshConnTLS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnTLS {
    return new MeshConnTLS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnTLS {
    return new MeshConnTLS().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnTLS | PlainMessage<MeshConnTLS> | undefined, b: MeshConnTLS | PlainMessage<MeshConnTLS> | undefined): boolean {
    return proto3.util.equals(MeshConnTLS, a, b);
  }
}

/**
 * ConnectRequest is sent by an application to a daemon to connect to a mesh.
 *
 * @generated from message v1.ConnectRequest
 */
export class ConnectRequest extends Message<ConnectRequest> {
  /**
   * ID is the unique identifier of the connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<ConnectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ConnectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectRequest {
    return new ConnectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectRequest {
    return new ConnectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectRequest {
    return new ConnectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectRequest | PlainMessage<ConnectRequest> | undefined, b: ConnectRequest | PlainMessage<ConnectRequest> | undefined): boolean {
    return proto3.util.equals(ConnectRequest, a, b);
  }
}

/**
 * ConnectResponse is returned by the Connect RPC.
 *
 * @generated from message v1.ConnectResponse
 */
export class ConnectResponse extends Message<ConnectResponse> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Node id is the unique identifier of the node.
   *
   * @generated from field: string nodeID = 2;
   */
  nodeID = "";

  /**
   * Mesh domain is the domain of the mesh.
   *
   * @generated from field: string meshDomain = 3;
   */
  meshDomain = "";

  /**
   * IPv4Address is the IPv4 address of the node.
   *
   * @generated from field: string ipv4Address = 4;
   */
  ipv4Address = "";

  /**
   * IPv6Address is the IPv6 address of the node.
   *
   * @generated from field: string ipv6Address = 5;
   */
  ipv6Address = "";

  /**
   * IPv4Network is the IPv4 network of the mesh.
   *
   * @generated from field: string ipv4Network = 6;
   */
  ipv4Network = "";

  /**
   * IPv6Network is the IPv6 network of the mesh.
   *
   * @generated from field: string ipv6Network = 7;
   */
  ipv6Network = "";

  constructor(data?: PartialMessage<ConnectResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ConnectResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nodeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "meshDomain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ipv4Address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ipv6Address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ipv4Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ipv6Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectResponse {
    return new ConnectResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectResponse {
    return new ConnectResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectResponse {
    return new ConnectResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectResponse | PlainMessage<ConnectResponse> | undefined, b: ConnectResponse | PlainMessage<ConnectResponse> | undefined): boolean {
    return proto3.util.equals(ConnectResponse, a, b);
  }
}

/**
 * DisconnectRequest is sent by an application to a daemon to disconnect from a mesh.
 *
 * @generated from message v1.DisconnectRequest
 */
export class DisconnectRequest extends Message<DisconnectRequest> {
  /**
   * ID is the unique identifier of the connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DisconnectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DisconnectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisconnectRequest {
    return new DisconnectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisconnectRequest {
    return new DisconnectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisconnectRequest {
    return new DisconnectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DisconnectRequest | PlainMessage<DisconnectRequest> | undefined, b: DisconnectRequest | PlainMessage<DisconnectRequest> | undefined): boolean {
    return proto3.util.equals(DisconnectRequest, a, b);
  }
}

/**
 * DisconnectResponse is returned by the Disconnect RPC.
 *
 * @generated from message v1.DisconnectResponse
 */
export class DisconnectResponse extends Message<DisconnectResponse> {
  constructor(data?: PartialMessage<DisconnectResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DisconnectResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisconnectResponse {
    return new DisconnectResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisconnectResponse {
    return new DisconnectResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisconnectResponse {
    return new DisconnectResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DisconnectResponse | PlainMessage<DisconnectResponse> | undefined, b: DisconnectResponse | PlainMessage<DisconnectResponse> | undefined): boolean {
    return proto3.util.equals(DisconnectResponse, a, b);
  }
}

/**
 * MetricsRequest is sent by the application to a daemon to retrieve interface metrics for a mesh connection.
 *
 * @generated from message v1.MetricsRequest
 */
export class MetricsRequest extends Message<MetricsRequest> {
  /**
   * IDs are the unique identifiers of the connections to retrieve metrics for.
   * If not provided, metrics for all known connections will be returned.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<MetricsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MetricsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsRequest {
    return new MetricsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsRequest {
    return new MetricsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsRequest {
    return new MetricsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsRequest | PlainMessage<MetricsRequest> | undefined, b: MetricsRequest | PlainMessage<MetricsRequest> | undefined): boolean {
    return proto3.util.equals(MetricsRequest, a, b);
  }
}

/**
 * MetricsResponse is a message containing interface metrics.
 *
 * @generated from message v1.MetricsResponse
 */
export class MetricsResponse extends Message<MetricsResponse> {
  /**
   * Interfaces is a map of network IDs to their interface metrics.
   *
   * @generated from field: map<string, v1.InterfaceMetrics> interfaces = 1;
   */
  interfaces: { [key: string]: InterfaceMetrics } = {};

  constructor(data?: PartialMessage<MetricsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MetricsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interfaces", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: InterfaceMetrics} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsResponse {
    return new MetricsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsResponse {
    return new MetricsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsResponse {
    return new MetricsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsResponse | PlainMessage<MetricsResponse> | undefined, b: MetricsResponse | PlainMessage<MetricsResponse> | undefined): boolean {
    return proto3.util.equals(MetricsResponse, a, b);
  }
}

/**
 * AppQueryRequest is sent by the application to a daemon to query a mesh's storage.
 *
 * @generated from message v1.AppQueryRequest
 */
export class AppQueryRequest extends Message<AppQueryRequest> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Query is the query to execute.
   *
   * @generated from field: v1.QueryRequest query = 2;
   */
  query?: QueryRequest;

  constructor(data?: PartialMessage<AppQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AppQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "message", T: QueryRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppQueryRequest {
    return new AppQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppQueryRequest {
    return new AppQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppQueryRequest {
    return new AppQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AppQueryRequest | PlainMessage<AppQueryRequest> | undefined, b: AppQueryRequest | PlainMessage<AppQueryRequest> | undefined): boolean {
    return proto3.util.equals(AppQueryRequest, a, b);
  }
}

/**
 * DropConnectionRequest is sent by the application to a daemon to drop all storage
 * and information for a mesh connection.
 *
 * @generated from message v1.DropConnectionRequest
 */
export class DropConnectionRequest extends Message<DropConnectionRequest> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DropConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DropConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropConnectionRequest {
    return new DropConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropConnectionRequest {
    return new DropConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropConnectionRequest {
    return new DropConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DropConnectionRequest | PlainMessage<DropConnectionRequest> | undefined, b: DropConnectionRequest | PlainMessage<DropConnectionRequest> | undefined): boolean {
    return proto3.util.equals(DropConnectionRequest, a, b);
  }
}

/**
 * DropConnectionResponse is a message returned for a drop request.
 *
 * @generated from message v1.DropConnectionResponse
 */
export class DropConnectionResponse extends Message<DropConnectionResponse> {
  constructor(data?: PartialMessage<DropConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DropConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropConnectionResponse {
    return new DropConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropConnectionResponse {
    return new DropConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropConnectionResponse {
    return new DropConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DropConnectionResponse | PlainMessage<DropConnectionResponse> | undefined, b: DropConnectionResponse | PlainMessage<DropConnectionResponse> | undefined): boolean {
    return proto3.util.equals(DropConnectionResponse, a, b);
  }
}

/**
 * StatusRequest is sent by the application to a daemon to retrieve the status of the daemon.
 *
 * @generated from message v1.StatusRequest
 */
export class StatusRequest extends Message<StatusRequest> {
  constructor(data?: PartialMessage<StatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.StatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusRequest {
    return new StatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StatusRequest | PlainMessage<StatusRequest> | undefined, b: StatusRequest | PlainMessage<StatusRequest> | undefined): boolean {
    return proto3.util.equals(StatusRequest, a, b);
  }
}

/**
 * DaemonStatus contains the information about the daemon.
 *
 * @generated from message v1.DaemonStatus
 */
export class DaemonStatus extends Message<DaemonStatus> {
  /**
   * NodeID is the unique identifier of the daemon.
   * This is used for mesh connections from the daemon.
   *
   * @generated from field: string nodeID = 1;
   */
  nodeID = "";

  /**
   * PublicKey is the public key of the daemon.
   *
   * @generated from field: string publicKey = 2;
   */
  publicKey = "";

  /**
   * Description is a description of the daemon.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Version is the version of the daemon.
   *
   * @generated from field: string version = 4;
   */
  version = "";

  /**
   * GitCommit is the git commit of the daemon.
   *
   * @generated from field: string gitCommit = 5;
   */
  gitCommit = "";

  /**
   * BuildDate is the build date of the daemon.
   *
   * @generated from field: string buildDate = 6;
   */
  buildDate = "";

  /**
   * Uptime is the uptime of the daemon.
   *
   * @generated from field: string uptime = 7;
   */
  uptime = "";

  /**
   * StartedAt is the time the daemon started.
   *
   * @generated from field: google.protobuf.Timestamp startedAt = 8;
   */
  startedAt?: Timestamp;

  /**
   * Connections are a map of known connections to the daemon and their statuses.
   *
   * @generated from field: map<string, v1.DaemonConnStatus> connections = 9;
   */
  connections: { [key: string]: DaemonConnStatus } = {};

  constructor(data?: PartialMessage<DaemonStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DaemonStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "publicKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gitCommit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "buildDate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "uptime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "startedAt", kind: "message", T: Timestamp },
    { no: 9, name: "connections", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(DaemonConnStatus)} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DaemonStatus {
    return new DaemonStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DaemonStatus {
    return new DaemonStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DaemonStatus {
    return new DaemonStatus().fromJsonString(jsonString, options);
  }

  static equals(a: DaemonStatus | PlainMessage<DaemonStatus> | undefined, b: DaemonStatus | PlainMessage<DaemonStatus> | undefined): boolean {
    return proto3.util.equals(DaemonStatus, a, b);
  }
}

