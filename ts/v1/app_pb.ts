//
//Copyright 2023 Avi Zimmerman <avi.zimmerman@gmail.com>
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file v1/app.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Feature, InterfaceMetrics, MeshNode } from "./node_pb.js";
import { QueryRequest } from "./storage_query_pb.js";

/**
 * NetworkAuthMethod are types of RPC credentials to supply to mesh nodes.
 *
 * @generated from enum v1.NetworkAuthMethod
 */
export enum NetworkAuthMethod {
  /**
   * NO_AUTH is used to indicate that no authentication is required.
   *
   * @generated from enum value: NO_AUTH = 0;
   */
  NO_AUTH = 0,

  /**
   * BASIC is used to indicate that basic authentication is required.
   *
   * @generated from enum value: BASIC = 1;
   */
  BASIC = 1,

  /**
   * LDAP is used to indicate that LDAP authentication is required.
   *
   * @generated from enum value: LDAP = 2;
   */
  LDAP = 2,

  /**
   * ID is used to indicate that an identity is required.
   *
   * @generated from enum value: ID = 3;
   */
  ID = 3,

  /**
   * MTLS is used to indicate that mutual TLS authentication is required.
   * The TLS object should be used to configure the TLS connection.
   *
   * @generated from enum value: MTLS = 4;
   */
  MTLS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(NetworkAuthMethod)
proto3.util.setEnumType(NetworkAuthMethod, "v1.NetworkAuthMethod", [
  { no: 0, name: "NO_AUTH" },
  { no: 1, name: "BASIC" },
  { no: 2, name: "LDAP" },
  { no: 3, name: "ID" },
  { no: 4, name: "MTLS" },
]);

/**
 * ConnectRequest is sent by an application to a daemon to establish a connection to a mesh.
 *
 * @generated from message v1.ConnectRequest
 */
export class ConnectRequest extends Message<ConnectRequest> {
  /**
   * ID is the unique identifier of this connection. If not provided
   * one will be generated.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * AuthMethod is the type of authentication to use.
   *
   * @generated from field: v1.NetworkAuthMethod authMethod = 2;
   */
  authMethod = NetworkAuthMethod.NO_AUTH;

  /**
   * AuthCredentials are additional credentials as required by the authType. 
   *
   * @generated from field: map<string, string> authCredentials = 3;
   */
  authCredentials: { [key: string]: string } = {};

  /**
   * AddrType is the type of join addresses in the addrs list.
   *
   * @generated from field: v1.ConnectRequest.AddrType addrType = 4;
   */
  addrType = ConnectRequest_AddrType.ADDR;

  /**
   * Addrs are the join addresses to use to connect to the mesh.
   *
   * @generated from field: repeated string addrs = 5;
   */
  addrs: string[] = [];

  /**
   * Networking is the networking configuration to use.
   *
   * @generated from field: v1.MeshConnNetworking networking = 6;
   */
  networking?: MeshConnNetworking;

  /**
   * Services are the services to expose to other nodes on the mesh.
   *
   * @generated from field: v1.MeshConnServices services = 7;
   */
  services?: MeshConnServices;

  /**
   * Bootstrap are options for bootstrapping a new mesh.
   *
   * @generated from field: v1.MeshConnBootstrap bootstrap = 8;
   */
  bootstrap?: MeshConnBootstrap;

  /**
   * TLS are TLS configurations for the mesh connection.
   *
   * @generated from field: v1.MeshConnTLS tls = 9;
   */
  tls?: MeshConnTLS;

  constructor(data?: PartialMessage<ConnectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ConnectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "authMethod", kind: "enum", T: proto3.getEnumType(NetworkAuthMethod) },
    { no: 3, name: "authCredentials", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "addrType", kind: "enum", T: proto3.getEnumType(ConnectRequest_AddrType) },
    { no: 5, name: "addrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "networking", kind: "message", T: MeshConnNetworking },
    { no: 7, name: "services", kind: "message", T: MeshConnServices },
    { no: 8, name: "bootstrap", kind: "message", T: MeshConnBootstrap },
    { no: 9, name: "tls", kind: "message", T: MeshConnTLS },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectRequest {
    return new ConnectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectRequest {
    return new ConnectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectRequest {
    return new ConnectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectRequest | PlainMessage<ConnectRequest> | undefined, b: ConnectRequest | PlainMessage<ConnectRequest> | undefined): boolean {
    return proto3.util.equals(ConnectRequest, a, b);
  }
}

/**
 * AddrType is the type of join addresses included in the request.
 *
 * @generated from enum v1.ConnectRequest.AddrType
 */
export enum ConnectRequest_AddrType {
  /**
   * ADDR is used to join a mesh using an IP or DNS address.
   *
   * @generated from enum value: ADDR = 0;
   */
  ADDR = 0,

  /**
   * MULTIADDR is used to join a mesh using a multiaddr.
   *
   * @generated from enum value: MULTIADDR = 1;
   */
  MULTIADDR = 1,

  /**
   * RENDEZVOUS is used to join a mesh using a rendezvous string.
   *
   * @generated from enum value: RENDEZVOUS = 2;
   */
  RENDEZVOUS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectRequest_AddrType)
proto3.util.setEnumType(ConnectRequest_AddrType, "v1.ConnectRequest.AddrType", [
  { no: 0, name: "ADDR" },
  { no: 1, name: "MULTIADDR" },
  { no: 2, name: "RENDEZVOUS" },
]);

/**
 * AuthHeader is an enumeration of headers that coorespond to the AuthMethod.
 * They are used to pass authentication credentials to the daemon. Enums 
 * cannot be used as map keys, so their string values are used instead.
 *
 * @generated from enum v1.ConnectRequest.AuthHeader
 */
export enum ConnectRequest_AuthHeader {
  /**
   * BASIC_USERNAME is the username for basic authentication.
   *
   * @generated from enum value: BASIC_USERNAME = 0;
   */
  BASIC_USERNAME = 0,

  /**
   * BASIC_PASSWORD is the password for basic authentication.
   *
   * @generated from enum value: BASIC_PASSWORD = 1;
   */
  BASIC_PASSWORD = 1,

  /**
   * LDAP_USERNAME is the username for LDAP authentication.
   *
   * @generated from enum value: LDAP_USERNAME = 2;
   */
  LDAP_USERNAME = 2,

  /**
   * LDAP_PASSWORD is the password for LDAP authentication.
   *
   * @generated from enum value: LDAP_PASSWORD = 3;
   */
  LDAP_PASSWORD = 3,

  /**
   * ADDRS_ENVELOPE is the header for a signed envelope containing
   * the join addresses to use to connect to the mesh.
   *
   * @generated from enum value: ADDRS_ENVELOPE = 4;
   */
  ADDRS_ENVELOPE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectRequest_AuthHeader)
proto3.util.setEnumType(ConnectRequest_AuthHeader, "v1.ConnectRequest.AuthHeader", [
  { no: 0, name: "BASIC_USERNAME" },
  { no: 1, name: "BASIC_PASSWORD" },
  { no: 2, name: "LDAP_USERNAME" },
  { no: 3, name: "LDAP_PASSWORD" },
  { no: 4, name: "ADDRS_ENVELOPE" },
]);

/**
 * MeshConnNetworking are configurations for networking on a mesh.
 *
 * @generated from message v1.MeshConnNetworking
 */
export class MeshConnNetworking extends Message<MeshConnNetworking> {
  /**
   * UseDNS indicates whether or not to use the DNS servers of the mesh.
   *
   * @generated from field: bool useDNS = 1;
   */
  useDNS = false;

  /**
   * Endpoints are wireguard endpoints to broadcast to the mesh.
   *
   * @generated from field: repeated string endpoints = 2;
   */
  endpoints: string[] = [];

  /**
   * DetectEndpoints enables endpoint detection.
   *
   * @generated from field: bool detectEndpoints = 3;
   */
  detectEndpoints = false;

  /**
   * DetectPrivateEndpoints enables endpoint detection for private addresses.
   * This only makes sense when DetectEndpoints is enabled.
   *
   * @generated from field: bool detectPrivateEndpoints = 4;
   */
  detectPrivateEndpoints = false;

  constructor(data?: PartialMessage<MeshConnNetworking>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnNetworking";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useDNS", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "detectEndpoints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "detectPrivateEndpoints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnNetworking {
    return new MeshConnNetworking().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnNetworking {
    return new MeshConnNetworking().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnNetworking {
    return new MeshConnNetworking().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnNetworking | PlainMessage<MeshConnNetworking> | undefined, b: MeshConnNetworking | PlainMessage<MeshConnNetworking> | undefined): boolean {
    return proto3.util.equals(MeshConnNetworking, a, b);
  }
}

/**
 * MeshConnServices are configurations for exposing services to other nodes on a mesh.
 *
 * @generated from message v1.MeshConnServices
 */
export class MeshConnServices extends Message<MeshConnServices> {
  /**
   * Enabled indicates whether or not to expose services to other nodes.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * EnableLibP2P indicates whether or not to serve the API over libp2p.
   *
   * @generated from field: bool enableLibP2P = 2;
   */
  enableLibP2P = false;

  /**
   * EnableTLS indicates whether or not to use TLS for the API.
   *
   * @generated from field: bool enableTLS = 3;
   */
  enableTLS = false;

  /**
   * Rendezvous is an optional rendezvous string to use for anouncing the service
   * on the IPFS DHT.
   *
   * @generated from field: string rendezvous = 4;
   */
  rendezvous = "";

  /**
   * ListenAddress is a raw IP address and port to listen on.
   *
   * @generated from field: string listenAddress = 5;
   */
  listenAddress = "";

  /**
   * ListenMultiaddrs are multiaddrs to listen on. If not provided and
   * EnableLibP2P is set, the default listen addresses will be used.
   *
   * @generated from field: repeated string listenMultiaddrs = 6;
   */
  listenMultiaddrs: string[] = [];

  /**
   * AuthMetod is the of authentication to enable for the services.
   * Only mTLS and ID are supported.
   *
   * @generated from field: v1.NetworkAuthMethod authMethod = 7;
   */
  authMethod = NetworkAuthMethod.NO_AUTH;

  /**
   * Features are which features to enable on the API.
   *
   * @generated from field: repeated v1.Feature features = 8;
   */
  features: Feature[] = [];

  /**
   * DNS are configurations for running a MeshDNS server.
   *
   * @generated from field: v1.MeshDNSService dns = 9;
   */
  dns?: MeshDNSService;

  constructor(data?: PartialMessage<MeshConnServices>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnServices";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "enableLibP2P", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "enableTLS", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "rendezvous", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "listenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "listenMultiaddrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "authMethod", kind: "enum", T: proto3.getEnumType(NetworkAuthMethod) },
    { no: 8, name: "features", kind: "enum", T: proto3.getEnumType(Feature), repeated: true },
    { no: 9, name: "dns", kind: "message", T: MeshDNSService },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnServices {
    return new MeshConnServices().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnServices {
    return new MeshConnServices().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnServices {
    return new MeshConnServices().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnServices | PlainMessage<MeshConnServices> | undefined, b: MeshConnServices | PlainMessage<MeshConnServices> | undefined): boolean {
    return proto3.util.equals(MeshConnServices, a, b);
  }
}

/**
 * MeshDNSService are configurations for running a MeshDNS server.
 *
 * @generated from message v1.MeshDNSService
 */
export class MeshDNSService extends Message<MeshDNSService> {
  /**
   * Enabled indicates whether or not to run a MeshDNS server.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * ListenUDP is a raw IP address and port to listen on for UDP.
   * Defaults to :53. Set to an empty string to disable.
   *
   * @generated from field: string listenUDP = 2;
   */
  listenUDP = "";

  /**
   * ListenTCP is a raw IP address and port to listen on for TCP.
   * Defaults to :53. Set to an empty string to disable.
   *
   * @generated from field: string listenTCP = 3;
   */
  listenTCP = "";

  constructor(data?: PartialMessage<MeshDNSService>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshDNSService";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "listenUDP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "listenTCP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshDNSService {
    return new MeshDNSService().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshDNSService {
    return new MeshDNSService().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshDNSService {
    return new MeshDNSService().fromJsonString(jsonString, options);
  }

  static equals(a: MeshDNSService | PlainMessage<MeshDNSService> | undefined, b: MeshDNSService | PlainMessage<MeshDNSService> | undefined): boolean {
    return proto3.util.equals(MeshDNSService, a, b);
  }
}

/**
 * MeshConnBootstrap are configurations for bootstrapping a new mesh.
 *
 * @generated from message v1.MeshConnBootstrap
 */
export class MeshConnBootstrap extends Message<MeshConnBootstrap> {
  /**
   * Enabled indicates whether or not to bootstrap a new mesh.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Domain is the domain of the mesh. Defaults to "webmesh.internal".
   *
   * @generated from field: string domain = 2;
   */
  domain = "";

  /**
   * IPv4Network is the IPv4 network of the mesh. Defaults to 172.16.0.0/12.
   *
   * @generated from field: string ipv4Network = 3;
   */
  ipv4Network = "";

  /**
   * RBACEnabled indicates whether or not to enable RBAC on the mesh.
   *
   * @generated from field: bool rbacEnabled = 4;
   */
  rbacEnabled = false;

  /**
   * DefaultNetworkACL is the default network ACL to use for the mesh.
   *
   * @generated from field: v1.MeshConnBootstrap.DefaultNetworkACL defaultNetworkACL = 5;
   */
  defaultNetworkACL = MeshConnBootstrap_DefaultNetworkACL.ACCEPT;

  constructor(data?: PartialMessage<MeshConnBootstrap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnBootstrap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ipv4Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "rbacEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "defaultNetworkACL", kind: "enum", T: proto3.getEnumType(MeshConnBootstrap_DefaultNetworkACL) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnBootstrap {
    return new MeshConnBootstrap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnBootstrap {
    return new MeshConnBootstrap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnBootstrap {
    return new MeshConnBootstrap().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnBootstrap | PlainMessage<MeshConnBootstrap> | undefined, b: MeshConnBootstrap | PlainMessage<MeshConnBootstrap> | undefined): boolean {
    return proto3.util.equals(MeshConnBootstrap, a, b);
  }
}

/**
 * @generated from enum v1.MeshConnBootstrap.DefaultNetworkACL
 */
export enum MeshConnBootstrap_DefaultNetworkACL {
  /**
   * @generated from enum value: ACCEPT = 0;
   */
  ACCEPT = 0,

  /**
   * @generated from enum value: DROP = 1;
   */
  DROP = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(MeshConnBootstrap_DefaultNetworkACL)
proto3.util.setEnumType(MeshConnBootstrap_DefaultNetworkACL, "v1.MeshConnBootstrap.DefaultNetworkACL", [
  { no: 0, name: "ACCEPT" },
  { no: 1, name: "DROP" },
]);

/**
 * MeshhConnTLS are TLS configurations for a mesh connection.
 *
 * @generated from message v1.MeshConnTLS
 */
export class MeshConnTLS extends Message<MeshConnTLS> {
  /**
   * Enabled indicates whether or not to use TLS.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * CACert is a base64 and PEM encoded CA certificate to use for TLS.
   *
   * @generated from field: string caCertData = 2;
   */
  caCertData = "";

  /**
   * CertData is a base64 and PEM encoded certificate to use for TLS.
   *
   * @generated from field: string certData = 3;
   */
  certData = "";

  /**
   * KeyData is a base64 and PEM encoded private key to use for TLS.
   *
   * @generated from field: string keyData = 4;
   */
  keyData = "";

  /**
   * VerifyChainOnly indicates whether or not to only verify the
   * certificate chain.
   *
   * @generated from field: bool verifyChainOnly = 5;
   */
  verifyChainOnly = false;

  /**
   * SkipVerify indicates whether or not to skip verification of the
   * server certificate.
   *
   * @generated from field: bool skipVerify = 6;
   */
  skipVerify = false;

  constructor(data?: PartialMessage<MeshConnTLS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MeshConnTLS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "caCertData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "certData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "keyData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "verifyChainOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "skipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeshConnTLS {
    return new MeshConnTLS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeshConnTLS {
    return new MeshConnTLS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeshConnTLS {
    return new MeshConnTLS().fromJsonString(jsonString, options);
  }

  static equals(a: MeshConnTLS | PlainMessage<MeshConnTLS> | undefined, b: MeshConnTLS | PlainMessage<MeshConnTLS> | undefined): boolean {
    return proto3.util.equals(MeshConnTLS, a, b);
  }
}

/**
 * ConnectResponse is returned by the Connect RPC.
 *
 * @generated from message v1.ConnectResponse
 */
export class ConnectResponse extends Message<ConnectResponse> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Node id is the unique identifier of the node.
   *
   * @generated from field: string nodeID = 2;
   */
  nodeID = "";

  /**
   * Mesh domain is the domain of the mesh.
   *
   * @generated from field: string meshDomain = 3;
   */
  meshDomain = "";

  /**
   * IPv4Address is the IPv4 address of the node.
   *
   * @generated from field: string ipv4Address = 4;
   */
  ipv4Address = "";

  /**
   * IPv6Address is the IPv6 address of the node.
   *
   * @generated from field: string ipv6Address = 5;
   */
  ipv6Address = "";

  /**
   * IPv4Network is the IPv4 network of the mesh.
   *
   * @generated from field: string ipv4Network = 6;
   */
  ipv4Network = "";

  /**
   * IPv6Network is the IPv6 network of the mesh.
   *
   * @generated from field: string ipv6Network = 7;
   */
  ipv6Network = "";

  constructor(data?: PartialMessage<ConnectResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ConnectResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nodeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "meshDomain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ipv4Address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ipv6Address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ipv4Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ipv6Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectResponse {
    return new ConnectResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectResponse {
    return new ConnectResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectResponse {
    return new ConnectResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectResponse | PlainMessage<ConnectResponse> | undefined, b: ConnectResponse | PlainMessage<ConnectResponse> | undefined): boolean {
    return proto3.util.equals(ConnectResponse, a, b);
  }
}

/**
 * DisconnectRequest is sent by an application to a daemon to disconnect from a mesh.
 *
 * @generated from message v1.DisconnectRequest
 */
export class DisconnectRequest extends Message<DisconnectRequest> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DisconnectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DisconnectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisconnectRequest {
    return new DisconnectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisconnectRequest {
    return new DisconnectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisconnectRequest {
    return new DisconnectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DisconnectRequest | PlainMessage<DisconnectRequest> | undefined, b: DisconnectRequest | PlainMessage<DisconnectRequest> | undefined): boolean {
    return proto3.util.equals(DisconnectRequest, a, b);
  }
}

/**
 * DisconnectResponse is returned by the Disconnect RPC.
 *
 * @generated from message v1.DisconnectResponse
 */
export class DisconnectResponse extends Message<DisconnectResponse> {
  constructor(data?: PartialMessage<DisconnectResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.DisconnectResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisconnectResponse {
    return new DisconnectResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisconnectResponse {
    return new DisconnectResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisconnectResponse {
    return new DisconnectResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DisconnectResponse | PlainMessage<DisconnectResponse> | undefined, b: DisconnectResponse | PlainMessage<DisconnectResponse> | undefined): boolean {
    return proto3.util.equals(DisconnectResponse, a, b);
  }
}

/**
 * MetricsRequest is sent by the application to a daemon to retrieve interface metrics for a mesh connection.
 *
 * @generated from message v1.MetricsRequest
 */
export class MetricsRequest extends Message<MetricsRequest> {
  /**
   * IDs are the unique identifiers of the connections to retrieve metrics for.
   * If not provided, metrics for all known connections will be returned.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<MetricsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MetricsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsRequest {
    return new MetricsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsRequest {
    return new MetricsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsRequest {
    return new MetricsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsRequest | PlainMessage<MetricsRequest> | undefined, b: MetricsRequest | PlainMessage<MetricsRequest> | undefined): boolean {
    return proto3.util.equals(MetricsRequest, a, b);
  }
}

/**
 * MetricsResponse is a message containing interface metrics.
 *
 * @generated from message v1.MetricsResponse
 */
export class MetricsResponse extends Message<MetricsResponse> {
  /**
   * Interfaces is a map of network IDs to their interface metrics.
   *
   * @generated from field: map<string, v1.InterfaceMetrics> interfaces = 1;
   */
  interfaces: { [key: string]: InterfaceMetrics } = {};

  constructor(data?: PartialMessage<MetricsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.MetricsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interfaces", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: InterfaceMetrics} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsResponse {
    return new MetricsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsResponse {
    return new MetricsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsResponse {
    return new MetricsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsResponse | PlainMessage<MetricsResponse> | undefined, b: MetricsResponse | PlainMessage<MetricsResponse> | undefined): boolean {
    return proto3.util.equals(MetricsResponse, a, b);
  }
}

/**
 * StatusRequest is sent by the application to a daemon to retrieve the status of a mesh connection.
 *
 * @generated from message v1.StatusRequest
 */
export class StatusRequest extends Message<StatusRequest> {
  /**
   * IDs are the unique identifiers of the connections to retrieve status for.
   * If not provided, status for all known connections will be returned.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<StatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.StatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusRequest {
    return new StatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StatusRequest | PlainMessage<StatusRequest> | undefined, b: StatusRequest | PlainMessage<StatusRequest> | undefined): boolean {
    return proto3.util.equals(StatusRequest, a, b);
  }
}

/**
 * StatusResponse is a message containing the status of the node.
 *
 * @generated from message v1.StatusResponse
 */
export class StatusResponse extends Message<StatusResponse> {
  /**
   * Statuses is a map of network IDs to their status.
   *
   * @generated from field: map<string, v1.ConnectionStatus> statuses = 1;
   */
  statuses: { [key: string]: ConnectionStatus } = {};

  constructor(data?: PartialMessage<StatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.StatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statuses", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ConnectionStatus} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusResponse {
    return new StatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusResponse {
    return new StatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusResponse {
    return new StatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StatusResponse | PlainMessage<StatusResponse> | undefined, b: StatusResponse | PlainMessage<StatusResponse> | undefined): boolean {
    return proto3.util.equals(StatusResponse, a, b);
  }
}

/**
 * ConnectionStatus is the status of a connection.
 *
 * @generated from message v1.ConnectionStatus
 */
export class ConnectionStatus extends Message<ConnectionStatus> {
  /**
   * ConnectionStatus is the status of the connection.
   *
   * @generated from field: v1.ConnectionStatus.Status connectionStatus = 1;
   */
  connectionStatus = ConnectionStatus_Status.DISCONNECTED;

  /**
   * Node is the node status. This is only populated if the node is connected.
   *
   * @generated from field: v1.MeshNode node = 2;
   */
  node?: MeshNode;

  constructor(data?: PartialMessage<ConnectionStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.ConnectionStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connectionStatus", kind: "enum", T: proto3.getEnumType(ConnectionStatus_Status) },
    { no: 2, name: "node", kind: "message", T: MeshNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionStatus {
    return new ConnectionStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionStatus {
    return new ConnectionStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionStatus {
    return new ConnectionStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionStatus | PlainMessage<ConnectionStatus> | undefined, b: ConnectionStatus | PlainMessage<ConnectionStatus> | undefined): boolean {
    return proto3.util.equals(ConnectionStatus, a, b);
  }
}

/**
 * @generated from enum v1.ConnectionStatus.Status
 */
export enum ConnectionStatus_Status {
  /**
   * DISCONNECTED indicates that the node is not connected to a mesh.
   *
   * @generated from enum value: DISCONNECTED = 0;
   */
  DISCONNECTED = 0,

  /**
   * CONNECTING indicates that the node is in the process of connecting to a mesh.
   *
   * @generated from enum value: CONNECTING = 1;
   */
  CONNECTING = 1,

  /**
   * CONNECTED indicates that the node is connected to a mesh.
   *
   * @generated from enum value: CONNECTED = 2;
   */
  CONNECTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionStatus_Status)
proto3.util.setEnumType(ConnectionStatus_Status, "v1.ConnectionStatus.Status", [
  { no: 0, name: "DISCONNECTED" },
  { no: 1, name: "CONNECTING" },
  { no: 2, name: "CONNECTED" },
]);

/**
 * AppQueryRequest is sent by the application to a daemon to query a mesh's storage.
 *
 * @generated from message v1.AppQueryRequest
 */
export class AppQueryRequest extends Message<AppQueryRequest> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Query is the query to execute.
   *
   * @generated from field: v1.QueryRequest query = 2;
   */
  query?: QueryRequest;

  constructor(data?: PartialMessage<AppQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AppQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "message", T: QueryRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppQueryRequest {
    return new AppQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppQueryRequest {
    return new AppQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppQueryRequest {
    return new AppQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AppQueryRequest | PlainMessage<AppQueryRequest> | undefined, b: AppQueryRequest | PlainMessage<AppQueryRequest> | undefined): boolean {
    return proto3.util.equals(AppQueryRequest, a, b);
  }
}

/**
 * AppDropRequest is sent by the application to a daemon to drop a mesh's storage.
 *
 * @generated from message v1.AppDropRequest
 */
export class AppDropRequest extends Message<AppDropRequest> {
  /**
   * ID is the unique identifier of this connection.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<AppDropRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AppDropRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppDropRequest {
    return new AppDropRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppDropRequest {
    return new AppDropRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppDropRequest {
    return new AppDropRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AppDropRequest | PlainMessage<AppDropRequest> | undefined, b: AppDropRequest | PlainMessage<AppDropRequest> | undefined): boolean {
    return proto3.util.equals(AppDropRequest, a, b);
  }
}

/**
 * AppDropResponse is a message returned for a drop request.
 *
 * @generated from message v1.AppDropResponse
 */
export class AppDropResponse extends Message<AppDropResponse> {
  constructor(data?: PartialMessage<AppDropResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.AppDropResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppDropResponse {
    return new AppDropResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppDropResponse {
    return new AppDropResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppDropResponse {
    return new AppDropResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AppDropResponse | PlainMessage<AppDropResponse> | undefined, b: AppDropResponse | PlainMessage<AppDropResponse> | undefined): boolean {
    return proto3.util.equals(AppDropResponse, a, b);
  }
}

